"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _logger = _interopRequireDefault(require("../logger.js"));

var _asyncbox = require("asyncbox");

const KEYCODE_ESC = 111;
const KEYCODE_BACK = 4;
const keyboardCommands = {};

keyboardCommands.hideKeyboard = async function hideKeyboard(timeoutMs = 1000) {
  let {
    isKeyboardShown,
    canCloseKeyboard
  } = await this.isSoftKeyboardPresent();

  if (!isKeyboardShown) {
    _logger.default.info('Keyboard has no UI; no closing necessary');

    return false;
  }

  for (const keyCode of [KEYCODE_ESC, KEYCODE_BACK]) {
    if (canCloseKeyboard) {
      await this.keyevent(keyCode);
    }

    try {
      return await (0, _asyncbox.waitForCondition)(async () => {
        ({
          isKeyboardShown
        } = await this.isSoftKeyboardPresent());
        return !isKeyboardShown;
      }, {
        waitMs: timeoutMs,
        intervalMs: 500
      });
    } catch (ign) {}
  }

  throw new Error(`The software keyboard cannot be hidden`);
};

keyboardCommands.isSoftKeyboardPresent = async function isSoftKeyboardPresent() {
  try {
    const stdout = await this.shell(['dumpsys', 'input_method']);
    const inputShownMatch = /mInputShown=(\w+)/.exec(stdout);
    const inputViewShownMatch = /mIsInputViewShown=(\w+)/.exec(stdout);
    return {
      isKeyboardShown: !!(inputShownMatch && inputShownMatch[1] === 'true'),
      canCloseKeyboard: !!(inputViewShownMatch && inputViewShownMatch[1] === 'true')
    };
  } catch (e) {
    throw new Error(`Error finding softkeyboard. Original error: ${e.message}`);
  }
};

var _default = keyboardCommands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9rZXlib2FyZC1jb21tYW5kcy5qcyJdLCJuYW1lcyI6WyJLRVlDT0RFX0VTQyIsIktFWUNPREVfQkFDSyIsImtleWJvYXJkQ29tbWFuZHMiLCJoaWRlS2V5Ym9hcmQiLCJ0aW1lb3V0TXMiLCJpc0tleWJvYXJkU2hvd24iLCJjYW5DbG9zZUtleWJvYXJkIiwiaXNTb2Z0S2V5Ym9hcmRQcmVzZW50IiwibG9nIiwiaW5mbyIsImtleUNvZGUiLCJrZXlldmVudCIsIndhaXRNcyIsImludGVydmFsTXMiLCJpZ24iLCJFcnJvciIsInN0ZG91dCIsInNoZWxsIiwiaW5wdXRTaG93bk1hdGNoIiwiZXhlYyIsImlucHV0Vmlld1Nob3duTWF0Y2giLCJlIiwibWVzc2FnZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQSxNQUFNQSxXQUFXLEdBQUcsR0FBcEI7QUFDQSxNQUFNQyxZQUFZLEdBQUcsQ0FBckI7QUFFQSxNQUFNQyxnQkFBZ0IsR0FBRyxFQUF6Qjs7QUFXQUEsZ0JBQWdCLENBQUNDLFlBQWpCLEdBQWdDLGVBQWVBLFlBQWYsQ0FBNkJDLFNBQVMsR0FBRyxJQUF6QyxFQUErQztBQUM3RSxNQUFJO0FBQUNDLElBQUFBLGVBQUQ7QUFBa0JDLElBQUFBO0FBQWxCLE1BQXNDLE1BQU0sS0FBS0MscUJBQUwsRUFBaEQ7O0FBQ0EsTUFBSSxDQUFDRixlQUFMLEVBQXNCO0FBQ3BCRyxvQkFBSUMsSUFBSixDQUFTLDBDQUFUOztBQUNBLFdBQU8sS0FBUDtBQUNEOztBQUVELE9BQUssTUFBTUMsT0FBWCxJQUFzQixDQUFDVixXQUFELEVBQWNDLFlBQWQsQ0FBdEIsRUFBbUQ7QUFDakQsUUFBSUssZ0JBQUosRUFBc0I7QUFDcEIsWUFBTSxLQUFLSyxRQUFMLENBQWNELE9BQWQsQ0FBTjtBQUNEOztBQUNELFFBQUk7QUFDRixhQUFPLE1BQU0sZ0NBQWlCLFlBQVk7QUFDeEMsU0FBQztBQUFDTCxVQUFBQTtBQUFELFlBQW9CLE1BQU0sS0FBS0UscUJBQUwsRUFBM0I7QUFDQSxlQUFPLENBQUNGLGVBQVI7QUFDRCxPQUhZLEVBR1Y7QUFBQ08sUUFBQUEsTUFBTSxFQUFFUixTQUFUO0FBQW9CUyxRQUFBQSxVQUFVLEVBQUU7QUFBaEMsT0FIVSxDQUFiO0FBSUQsS0FMRCxDQUtFLE9BQU9DLEdBQVAsRUFBWSxDQUFFO0FBQ2pCOztBQUNELFFBQU0sSUFBSUMsS0FBSixDQUFXLHdDQUFYLENBQU47QUFDRCxDQW5CRDs7QUFnQ0FiLGdCQUFnQixDQUFDSyxxQkFBakIsR0FBeUMsZUFBZUEscUJBQWYsR0FBd0M7QUFDL0UsTUFBSTtBQUNGLFVBQU1TLE1BQU0sR0FBRyxNQUFNLEtBQUtDLEtBQUwsQ0FBVyxDQUFDLFNBQUQsRUFBWSxjQUFaLENBQVgsQ0FBckI7QUFDQSxVQUFNQyxlQUFlLEdBQUcsb0JBQW9CQyxJQUFwQixDQUF5QkgsTUFBekIsQ0FBeEI7QUFDQSxVQUFNSSxtQkFBbUIsR0FBRywwQkFBMEJELElBQTFCLENBQStCSCxNQUEvQixDQUE1QjtBQUNBLFdBQU87QUFDTFgsTUFBQUEsZUFBZSxFQUFFLENBQUMsRUFBRWEsZUFBZSxJQUFJQSxlQUFlLENBQUMsQ0FBRCxDQUFmLEtBQXVCLE1BQTVDLENBRGI7QUFFTFosTUFBQUEsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFYyxtQkFBbUIsSUFBSUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixLQUEyQixNQUFwRDtBQUZkLEtBQVA7QUFJRCxHQVJELENBUUUsT0FBT0MsQ0FBUCxFQUFVO0FBQ1YsVUFBTSxJQUFJTixLQUFKLENBQVcsK0NBQThDTSxDQUFDLENBQUNDLE9BQVEsRUFBbkUsQ0FBTjtBQUNEO0FBQ0YsQ0FaRDs7ZUFjZXBCLGdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcblxuY29uc3QgS0VZQ09ERV9FU0MgPSAxMTE7XG5jb25zdCBLRVlDT0RFX0JBQ0sgPSA0O1xuXG5jb25zdCBrZXlib2FyZENvbW1hbmRzID0ge307XG5cbi8qKlxuICogSGlkZXMgc29mdHdhcmUga2V5Ym9hcmQgaWYgaXQgaXMgdmlzaWJsZS5cbiAqIE5vb3AgaWYgdGhlIGtleWJvYXJkIGlzIGFscmVhZHkgaGlkZGVuLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzEwMDBdIEZvciBob3cgbG9uZyB0byB3YWl0IChpbiBtaWxsaXNlY29uZHMpXG4gKiB1bnRpbCB0aGUga2V5Ym9hcmQgaXMgYWN0dWFsbHkgaGlkZGVuLlxuICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgdGhlIGtleWJvYXJkIHdhcyBhbHJlYWR5IGhpZGRlblxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXlib2FyZCBjYW5ub3QgYmUgaGlkZGVuLlxuICovXG5rZXlib2FyZENvbW1hbmRzLmhpZGVLZXlib2FyZCA9IGFzeW5jIGZ1bmN0aW9uIGhpZGVLZXlib2FyZCAodGltZW91dE1zID0gMTAwMCkge1xuICBsZXQge2lzS2V5Ym9hcmRTaG93biwgY2FuQ2xvc2VLZXlib2FyZH0gPSBhd2FpdCB0aGlzLmlzU29mdEtleWJvYXJkUHJlc2VudCgpO1xuICBpZiAoIWlzS2V5Ym9hcmRTaG93bikge1xuICAgIGxvZy5pbmZvKCdLZXlib2FyZCBoYXMgbm8gVUk7IG5vIGNsb3NpbmcgbmVjZXNzYXJ5Jyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRyeSBFU0MgdGhlbiBCQUNLIGlmIHRoZSBmaXJzdCBvbmUgZmFpbHNcbiAgZm9yIChjb25zdCBrZXlDb2RlIG9mIFtLRVlDT0RFX0VTQywgS0VZQ09ERV9CQUNLXSkge1xuICAgIGlmIChjYW5DbG9zZUtleWJvYXJkKSB7XG4gICAgICBhd2FpdCB0aGlzLmtleWV2ZW50KGtleUNvZGUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAoe2lzS2V5Ym9hcmRTaG93bn0gPSBhd2FpdCB0aGlzLmlzU29mdEtleWJvYXJkUHJlc2VudCgpKTtcbiAgICAgICAgcmV0dXJuICFpc0tleWJvYXJkU2hvd247XG4gICAgICB9LCB7d2FpdE1zOiB0aW1lb3V0TXMsIGludGVydmFsTXM6IDUwMH0pO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzb2Z0d2FyZSBrZXlib2FyZCBjYW5ub3QgYmUgaGlkZGVuYCk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEtleWJvYXJkU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNLZXlib2FyZFNob3duIC0gV2hldGhlciBzb2Z0IGtleWJvYXJkIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5DbG9zZUtleWJvYXJkIC0gV2hldGhlciB0aGUga2V5Ym9hcmQgY2FuIGJlIGNsb3NlZC5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBzdGF0ZSBvZiB0aGUgc29mdHdhcmUga2V5Ym9hcmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge0tleWJvYXJkU3RhdGV9IFRoZSBrZXlib2FyZCBzdGF0ZS5cbiAqL1xua2V5Ym9hcmRDb21tYW5kcy5pc1NvZnRLZXlib2FyZFByZXNlbnQgPSBhc3luYyBmdW5jdGlvbiBpc1NvZnRLZXlib2FyZFByZXNlbnQgKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydkdW1wc3lzJywgJ2lucHV0X21ldGhvZCddKTtcbiAgICBjb25zdCBpbnB1dFNob3duTWF0Y2ggPSAvbUlucHV0U2hvd249KFxcdyspLy5leGVjKHN0ZG91dCk7XG4gICAgY29uc3QgaW5wdXRWaWV3U2hvd25NYXRjaCA9IC9tSXNJbnB1dFZpZXdTaG93bj0oXFx3KykvLmV4ZWMoc3Rkb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNLZXlib2FyZFNob3duOiAhIShpbnB1dFNob3duTWF0Y2ggJiYgaW5wdXRTaG93bk1hdGNoWzFdID09PSAndHJ1ZScpLFxuICAgICAgY2FuQ2xvc2VLZXlib2FyZDogISEoaW5wdXRWaWV3U2hvd25NYXRjaCAmJiBpbnB1dFZpZXdTaG93bk1hdGNoWzFdID09PSAndHJ1ZScpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZpbmRpbmcgc29mdGtleWJvYXJkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtleWJvYXJkQ29tbWFuZHM7XG4iXSwiZmlsZSI6ImxpYi90b29scy9rZXlib2FyZC1jb21tYW5kcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
