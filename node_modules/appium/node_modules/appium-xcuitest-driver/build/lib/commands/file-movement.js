"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.commands = void 0;
exports.parseContainerPath = parseContainerPath;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger"));

var _appiumIosDevice = require("appium-ios-device");

var _iosFsHelpers = require("../ios-fs-helpers");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const CONTAINER_DOCUMENTS_PATH = 'Documents';
const OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';
const commands = {};
exports.commands = commands;

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function createAfcClient(udid, bundleId, containerType) {
  if (!bundleId) {
    return await _appiumIosDevice.services.startAfcService(udid);
  }

  const service = await _appiumIosDevice.services.startHouseArrestService(udid);
  return isDocumentsContainer(containerType) ? await service.vendDocuments(bundleId) : await service.vendContainer(bundleId);
}

function isDocumentsContainer(containerType) {
  return _lodash.default.toLower(containerType) === _lodash.default.toLower(CONTAINER_DOCUMENTS_PATH);
}

async function createService(udid, remotePath) {
  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer,
      containerType
    } = await parseContainerPath(remotePath);
    const service = await createAfcClient(udid, bundleId, containerType);
    const relativePath = isDocumentsContainer(containerType) ? _path.default.join(CONTAINER_DOCUMENTS_PATH, pathInContainer) : pathInContainer;
    return {
      service,
      relativePath
    };
  } else {
    const service = await createAfcClient(udid);
    return {
      service,
      relativePath: remotePath
    };
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  if (_lodash.default.isNil(containerRootSupplier)) {
    const pathInContainer = relativePath;
    return {
      bundleId,
      pathInContainer,
      containerType
    };
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
    }

    await _appiumSupport.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _appiumSupport.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _appiumSupport.fs.writeFile(dstPath, buffer);
    await device.simctl.addMedia(dstPath);
  } finally {
    await _appiumSupport.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await (0, _iosFsHelpers.pushFile)(service, relativePath, base64Data);
  } catch (e) {
    _logger.default.debug(e.stack);

    throw new Error(`Could not push the file to '${remotePath}'.  Original error: ${e.message}`);
  } finally {
    service.close();
  }
}

async function deleteFileOrFolder(device, remotePath, isSimulator) {
  return isSimulator ? await deleteFromSimulator(device, remotePath) : await deleteFromRealDevice(device, remotePath);
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _appiumSupport.util.toInMemoryBase64(pathOnServer) : await _appiumSupport.zip.toInMemoryZip(pathOnServer, {
    encodeToBase64: true
  });
  return buffer.toString();
}

async function pullFromRealDevice(device, remotePath, isFile) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    const fileInfo = await service.getFileInfo(relativePath);

    if (isFile && fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);
    }

    if (!isFile && !fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);
    }

    return fileInfo.isFile() ? (await (0, _iosFsHelpers.pullFile)(service, relativePath)).toString('base64') : (await (0, _iosFsHelpers.pullFolder)(service, relativePath)).toString();
  } finally {
    service.close();
  }
}

async function deleteFromSimulator(device, remotePath) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `'${dstPath}' will be deleted`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote path at '${pathOnServer}' does not exist`);
  }

  await _appiumSupport.fs.rimraf(pathOnServer);
}

async function deleteFromRealDevice(device, remotePath) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await service.deleteDirectory(relativePath);
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

commands.mobileDeleteFolder = async function mobileDeleteFolder(opts = {}) {
  let {
    remotePath
  } = opts;

  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.mobileDeleteFile = async function mobileDeleteFile(opts = {}) {
  const {
    remotePath
  } = opts;

  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJDT05UQUlORVJfRE9DVU1FTlRTX1BBVEgiLCJPQkpFQ1RfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UiLCJjb21tYW5kcyIsInZlcmlmeUlzU3ViUGF0aCIsIm9yaWdpbmFsUGF0aCIsInJvb3QiLCJub3JtYWxpemVkUm9vdCIsInBhdGgiLCJub3JtYWxpemUiLCJub3JtYWxpemVkUGF0aCIsImRpcm5hbWUiLCJzdGFydHNXaXRoIiwibG9nIiwiZXJyb3JBbmRUaHJvdyIsImNyZWF0ZUFmY0NsaWVudCIsInVkaWQiLCJidW5kbGVJZCIsImNvbnRhaW5lclR5cGUiLCJzZXJ2aWNlcyIsInN0YXJ0QWZjU2VydmljZSIsInNlcnZpY2UiLCJzdGFydEhvdXNlQXJyZXN0U2VydmljZSIsImlzRG9jdW1lbnRzQ29udGFpbmVyIiwidmVuZERvY3VtZW50cyIsInZlbmRDb250YWluZXIiLCJfIiwidG9Mb3dlciIsImNyZWF0ZVNlcnZpY2UiLCJyZW1vdGVQYXRoIiwidGVzdCIsInBhdGhJbkNvbnRhaW5lciIsInBhcnNlQ29udGFpbmVyUGF0aCIsInJlbGF0aXZlUGF0aCIsImpvaW4iLCJjb250YWluZXJSb290U3VwcGxpZXIiLCJtYXRjaCIsImV4ZWMiLCJ0eXBlU2VwYXJhdG9yUG9zIiwiaW5kZXhPZiIsImxlbmd0aCIsInN1YnN0cmluZyIsImRlYnVnIiwiaXNOaWwiLCJjb250YWluZXJSb290IiwiaXNGdW5jdGlvbiIsInBvc2l4IiwicmVzb2x2ZSIsInB1c2hGaWxlVG9TaW11bGF0b3IiLCJkZXZpY2UiLCJiYXNlNjREYXRhIiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImRzdFBhdGgiLCJhcHBCdW5kbGUiLCJzaW1jdGwiLCJnZXRBcHBDb250YWluZXIiLCJpbmZvIiwiZnMiLCJleGlzdHMiLCJ3cml0ZUZpbGUiLCJkc3RGb2xkZXIiLCJ0ZW1wRGlyIiwib3BlbkRpciIsImJhc2VuYW1lIiwiYWRkTWVkaWEiLCJyaW1yYWYiLCJwdXNoRmlsZVRvUmVhbERldmljZSIsImUiLCJzdGFjayIsIkVycm9yIiwibWVzc2FnZSIsImNsb3NlIiwiZGVsZXRlRmlsZU9yRm9sZGVyIiwiaXNTaW11bGF0b3IiLCJkZWxldGVGcm9tU2ltdWxhdG9yIiwiZGVsZXRlRnJvbVJlYWxEZXZpY2UiLCJwdWxsRnJvbVNpbXVsYXRvciIsImlzRmlsZSIsInBhdGhPblNlcnZlciIsInNpbVJvb3QiLCJnZXREaXIiLCJ1dGlsIiwidG9Jbk1lbW9yeUJhc2U2NCIsInppcCIsInRvSW5NZW1vcnlaaXAiLCJlbmNvZGVUb0Jhc2U2NCIsInRvU3RyaW5nIiwicHVsbEZyb21SZWFsRGV2aWNlIiwiZmlsZUluZm8iLCJnZXRGaWxlSW5mbyIsImlzRGlyZWN0b3J5IiwiZGVsZXRlRGlyZWN0b3J5IiwiaW5jbHVkZXMiLCJwdXNoRmlsZSIsImVuZHNXaXRoIiwiaXNBcnJheSIsIm9wdHMiLCJwdWxsRmlsZSIsIm1vYmlsZURlbGV0ZUZvbGRlciIsIm1vYmlsZURlbGV0ZUZpbGUiLCJwdWxsRm9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxxQkFBcUIsR0FBRyxHQUE5QjtBQUVBLE1BQU1DLHNCQUFzQixHQUFHLElBQUlDLE1BQUosQ0FBWSxJQUFHRixxQkFBc0IsY0FBckMsQ0FBL0I7QUFDQSxNQUFNRyx3QkFBd0IsR0FBRyxHQUFqQztBQUNBLE1BQU1DLHdCQUF3QixHQUFHLFdBQWpDO0FBQ0EsTUFBTUMsOEJBQThCLEdBQUcsa0JBQXZDO0FBRUEsTUFBTUMsUUFBUSxHQUFHLEVBQWpCOzs7QUFFQSxTQUFTQyxlQUFULENBQTBCQyxZQUExQixFQUF3Q0MsSUFBeEMsRUFBOEM7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QixDQUY1QjtBQUdELENBUEQ7O2VBVWUxQixRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZzLCB0ZW1wRGlyLCBta2RpcnAsIHppcCwgdXRpbCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICdhcHBpdW0taW9zLWRldmljZSc7XG5pbXBvcnQgeyBwdWxsRmlsZSwgcHVsbEZvbGRlciwgcHVzaEZpbGUgfSBmcm9tICcuLi9pb3MtZnMtaGVscGVycyc7XG5cbmNvbnN0IENPTlRBSU5FUl9QQVRIX01BUktFUiA9ICdAJztcbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvUExkQjBHLzJcbmNvbnN0IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4gPSBuZXcgUmVnRXhwKGBeJHtDT05UQUlORVJfUEFUSF9NQVJLRVJ9KFteL10rKS8oLiopYCk7XG5jb25zdCBDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IgPSAnOic7XG5jb25zdCBDT05UQUlORVJfRE9DVU1FTlRTX1BBVEggPSAnRG9jdW1lbnRzJztcbmNvbnN0IE9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSA9ICdPQkpFQ1RfTk9UX0ZPVU5EJztcblxuY29uc3QgY29tbWFuZHMgPSB7fTtcblxuZnVuY3Rpb24gdmVyaWZ5SXNTdWJQYXRoIChvcmlnaW5hbFBhdGgsIHJvb3QpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFJvb3QgPSBwYXRoLm5vcm1hbGl6ZShyb290KTtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKSk7XG4gIC8vIElmIG9yaWdpbmFsUGF0aCBpcyByb290LCBgL2AsIG9yaWdpbmFsUGF0aCBzaG91bGQgZXF1YWwgdG8gbm9ybWFsaXplZFJvb3RcbiAgaWYgKG5vcm1hbGl6ZWRSb290ICE9PSBvcmlnaW5hbFBhdGggJiYgIW5vcm1hbGl6ZWRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFJvb3QpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCcke25vcm1hbGl6ZWRQYXRofScgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdWJwYXRoIG9mICcke25vcm1hbGl6ZWRSb290fSdgKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZmNDbGllbnQgKHVkaWQsIGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKSB7XG4gIGlmICghYnVuZGxlSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VydmljZXMuc3RhcnRBZmNTZXJ2aWNlKHVkaWQpO1xuICB9XG4gIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEhvdXNlQXJyZXN0U2VydmljZSh1ZGlkKTtcbiAgcmV0dXJuIGlzRG9jdW1lbnRzQ29udGFpbmVyKGNvbnRhaW5lclR5cGUpXG4gICAgPyBhd2FpdCBzZXJ2aWNlLnZlbmREb2N1bWVudHMoYnVuZGxlSWQpXG4gICAgOiBhd2FpdCBzZXJ2aWNlLnZlbmRDb250YWluZXIoYnVuZGxlSWQpO1xufVxuXG5mdW5jdGlvbiBpc0RvY3VtZW50c0NvbnRhaW5lciAoY29udGFpbmVyVHlwZSkge1xuICByZXR1cm4gXy50b0xvd2VyKGNvbnRhaW5lclR5cGUpID09PSBfLnRvTG93ZXIoQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VydmljZSAodWRpZCwgcmVtb3RlUGF0aCkge1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGV9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgpO1xuICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjcmVhdGVBZmNDbGllbnQodWRpZCwgYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGlzRG9jdW1lbnRzQ29udGFpbmVyKGNvbnRhaW5lclR5cGUpXG4gICAgICA/IHBhdGguam9pbihDT05UQUlORVJfRE9DVU1FTlRTX1BBVEgsIHBhdGhJbkNvbnRhaW5lcilcbiAgICAgIDogcGF0aEluQ29udGFpbmVyO1xuICAgIHJldHVybiB7c2VydmljZSwgcmVsYXRpdmVQYXRofTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgY3JlYXRlQWZjQ2xpZW50KHVkaWQpO1xuICAgIHJldHVybiB7c2VydmljZSwgcmVsYXRpdmVQYXRoOiByZW1vdGVQYXRofTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRhaW5lck9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBidW5kbGVJZCAtIFRoZSBwYXJzZWQgYnVuZGxlIGlkZW50aWZpZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoSW5Db250YWluZXIgLSBUaGUgYWJzb2x1dGUgZnVsbCBwYXRoIG9mIHRoZSBpdGVtIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBjb250YWluZXJUeXBlIC0gVGhlIGNvbnRhaW5lciB0eXBlXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFjdHVhbCBwYXRoIGFuZCB0aGUgYnVuZGxlIGlkZW50aWZpZXIgZnJvbSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBnaXZlbiBwYXRoIHN0cmluZy4gVGhlIHN0cmluZyBzaG91bGRcbiAqIG1hdGNoIGBDT05UQUlORVJfUEFUSF9QQVRURVJOYCByZWdleHAsIG90aGVyd2lzZSBhbiBlcnJvciBpcyBnb2luZ1xuICogdG8gYmUgdGhyb3duLiBBIHZhbGlkIHN0cmluZyBleGFtcGxlOiBgQGJ1bmRsZS5pZGVudGlmaWVyOmNvbnRhaW5lcl90eXBlL3JlbGF0aXZlX3BhdGhfaW5fY29udGFpbmVyYFxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGNvbnRhaW5lclJvb3RTdXBwbGllciAtIEVpdGhlciBhIHN0cmluZywgdGhhdCBjb250YWluc1xuICogZnVsbCBwYXRoIHRvIHRoZSBtb3VudCByb290IGZvciByZWFsIGRldmljZXMgb3IgYSBmdW5jdGlvbiwgd2hpY2ggYWNjZXB0cyB0d28gcGFyYW1ldGVyc1xuICogKGJ1bmRsZSBpZGVudGlmaWVyIGFuZCBvcHRpb25hbCBjb250YWluZXIgdHlwZSkgYW5kIHJldHVybnMgZnVsbCBwYXRoIHRvIGNvbnRhaW5lclxuICogcm9vdCBmb2xkZXIgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLCBmb3IgU2ltdWxhdG9yXG4gKiBAcmV0dXJucyB7Q29udGFpbmVyT2JqZWN0fVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbnRhaW5lclBhdGggKHJlbW90ZVBhdGgsIGNvbnRhaW5lclJvb3RTdXBwbGllcikge1xuICBjb25zdCBtYXRjaCA9IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4uZXhlYyhyZW1vdGVQYXRoKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHBhY2thZ2UgaWRlbnRpZmllciBgICtcbiAgICAgIGBzdGFydHMgd2l0aCAnJHtDT05UQUlORVJfUEFUSF9NQVJLRVJ9JyBhbmQgaXMgc2VwYXJhdGVkIGZyb20gdGhlIGAgK1xuICAgICAgYHJlbGF0aXZlIHBhdGggd2l0aCBhIHNpbmdsZSBzbGFzaC4gJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBsZXQgWywgYnVuZGxlSWQsIHJlbGF0aXZlUGF0aF0gPSBtYXRjaDtcbiAgbGV0IGNvbnRhaW5lclR5cGUgPSBudWxsO1xuICBjb25zdCB0eXBlU2VwYXJhdG9yUG9zID0gYnVuZGxlSWQuaW5kZXhPZihDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IpO1xuICAvLyBXZSBvbmx5IGNvbnNpZGVyIGNvbnRhaW5lciB0eXBlIGV4aXN0cyBpZiBpdHMgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gIC8vIG5vdCBjb3VudGluZyB0aGUgY29sb25cbiAgaWYgKHR5cGVTZXBhcmF0b3JQb3MgPiAwICYmIHR5cGVTZXBhcmF0b3JQb3MgPCBidW5kbGVJZC5sZW5ndGggLSAxKSB7XG4gICAgY29udGFpbmVyVHlwZSA9IGJ1bmRsZUlkLnN1YnN0cmluZyh0eXBlU2VwYXJhdG9yUG9zICsgMSk7XG4gICAgbG9nLmRlYnVnKGBQYXJzZWQgY29udGFpbmVyIHR5cGU6ICR7Y29udGFpbmVyVHlwZX1gKTtcbiAgICBidW5kbGVJZCA9IGJ1bmRsZUlkLnN1YnN0cmluZygwLCB0eXBlU2VwYXJhdG9yUG9zKTtcbiAgfVxuICBpZiAoXy5pc05pbChjb250YWluZXJSb290U3VwcGxpZXIpKSB7XG4gICAgY29uc3QgcGF0aEluQ29udGFpbmVyID0gcmVsYXRpdmVQYXRoO1xuICAgIHJldHVybiB7IGJ1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGUgfTtcbiAgfVxuICBjb25zdCBjb250YWluZXJSb290ID0gXy5pc0Z1bmN0aW9uKGNvbnRhaW5lclJvb3RTdXBwbGllcilcbiAgICA/IGF3YWl0IGNvbnRhaW5lclJvb3RTdXBwbGllcihidW5kbGVJZCwgY29udGFpbmVyVHlwZSlcbiAgICA6IGNvbnRhaW5lclJvb3RTdXBwbGllcjtcbiAgY29uc3QgcGF0aEluQ29udGFpbmVyID0gcGF0aC5wb3NpeC5yZXNvbHZlKGNvbnRhaW5lclJvb3QsIHJlbGF0aXZlUGF0aCk7XG4gIHZlcmlmeUlzU3ViUGF0aChwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclJvb3QpO1xuICByZXR1cm4ge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGV9O1xufVxuXG4vKipcbiAqIFNhdmUgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIGNodW5rIGFzIGEgYmluYXJ5IGZpbGUgb24gdGhlIFNpbXVsYXRvciB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIsIGZvciBleGFtcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAY29tLm15YXBwLmJsYTpkYXRhL1JlbGF0aXZlUGF0aEluQ29udGFpbmVyLzExMS5wbmcnLiBUaGUgJ0AnIGNoYXJhY3RlciBhdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5uaW5nIG9mIHRoZSBhcmd1bWVudCBpcyBtYW5kYXRvcnkgaW4gc3VjaCBjYXNlLiBUaGUgY29sb24gYXQgdGhlIGVuZCBvZiBidW5kbGUgaWRlbnRpZmllclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBvcHRpb25hbCBhbmQgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCB0aGUgY29udGFpbmVyIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIHZhbHVlcyB0aGVyZSBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzICdhcHAnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmVsYXRpdmUgZm9sZGVyIHBhdGggaXMgaWdub3JlZCBpZiB0aGUgZmlsZSBpcyBnb2luZyB0byBiZSB1cGxvYWRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIgYW5kIG9ubHkgdGhlIGZpbGUgbmFtZSBpcyBjb25zaWRlcmVkIGltcG9ydGFudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjREYXRhIC0gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlVG9TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjREYXRhLCAnYmFzZTY0Jyk7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7YnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lcjogZHN0UGF0aH0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCxcbiAgICAgIGFzeW5jIChhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpID0+IGF3YWl0IGRldmljZS5zaW1jdGwuZ2V0QXBwQ29udGFpbmVyKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkpO1xuICAgIGxvZy5pbmZvKGBQYXJzZWQgYnVuZGxlIGlkZW50aWZpZXIgJyR7YnVuZGxlSWR9JyBmcm9tICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICBgV2lsbCBwdXQgdGhlIGRhdGEgaW50byAnJHtkc3RQYXRofSdgKTtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgICBsb2cuZGVidWcoYFRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgJyR7cGF0aC5kaXJuYW1lKGRzdFBhdGgpfScgZG9lcyBub3QgZXhpc3QuIENyZWF0aW5nLi4uYCk7XG4gICAgICBhd2FpdCBta2RpcnAocGF0aC5kaXJuYW1lKGRzdFBhdGgpKTtcbiAgICB9XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdFBhdGgsIGJ1ZmZlcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRzdEZvbGRlciA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRzdEZvbGRlciwgcGF0aC5iYXNlbmFtZShyZW1vdGVQYXRoKSk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdFBhdGgsIGJ1ZmZlcik7XG4gICAgYXdhaXQgZGV2aWNlLnNpbWN0bC5hZGRNZWRpYShkc3RQYXRoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYoZHN0Rm9sZGVyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhdmUgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIGNodW5rIGFzIGEgYmluYXJ5IGZpbGUgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9ubHkgc3VwcG9ydGVkIGNvbnRhaW5lciB0eXBlIGlzICdkb2N1bWVudHMnLiBJZiB0aGUgY29udGFpbmVyIHR5cGUgaXMgbm90IHNldFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBsaWNpdGx5IGZvciBhIGJ1bmRsZSBpZCwgdGhlbiB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb250YWluZXIgaXMgZ29pbmcgdG8gYmUgbW91bnRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWthIC0tY29udGFpbmVyIGlmdXNlIGFyZ3VtZW50KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmcuIElmIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvMTExLnBuZ2AgaXMgcHJvdmlkZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YCBpbiBGaWxlcyBhcHAgd2lsbCBiZSBtb3VudGVkIGluIHRoZSBob3N0IG1hY2hpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQmFzZTY0IGVuY29kZWQgYDExMS5wbmdgIHdpbGwgYmUgcHVzaGVkIGludG8gYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+LzExMS5wbmdgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgYmFzZTY0IGRlY29kZWQgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjREYXRhIC0gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlVG9SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgY29uc3Qge3NlcnZpY2UsIHJlbGF0aXZlUGF0aH0gPSBhd2FpdCBjcmVhdGVTZXJ2aWNlKGRldmljZS51ZGlkLCByZW1vdGVQYXRoKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwdXNoRmlsZShzZXJ2aWNlLCByZWxhdGl2ZVBhdGgsIGJhc2U2NERhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGUuc3RhY2spO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHB1c2ggdGhlIGZpbGUgdG8gJyR7cmVtb3RlUGF0aH0nLiAgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVGaWxlT3JGb2xkZXIgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNTaW11bGF0b3IpIHtcbiAgcmV0dXJuIGlzU2ltdWxhdG9yXG4gICAgPyBhd2FpdCBkZWxldGVGcm9tU2ltdWxhdG9yKGRldmljZSwgcmVtb3RlUGF0aClcbiAgICA6IGF3YWl0IGRlbGV0ZUZyb21SZWFsRGV2aWNlKGRldmljZSwgcmVtb3RlUGF0aCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgb3IgZm9sZGVyIGZyb20gaU9TIFNpbXVsYXRvciBhbmQgcmV0dXJuIGl0IGFzIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBGb2xkZXIgY29udGVudCBpcyByZWN1cnNpdmVseSBwYWNrZWQgaW50byBhIHppcCBhcmNoaXZlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhIGZpbGUgb3IgYSBmb2xkZXIsIHdoaWNoIGV4aXN0cyBpbiB0aGUgY29ycmVzcG9uZGluZyBhcHBsaWNhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgb24gU2ltdWxhdG9yLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIGNvbnRhaW5lciB0eXBlcyBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHR5cGUgaXMgJ2FwcCcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsZSAtIFdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIGl0ZW0gaXMgYSBmaWxlIG9yIGEgZm9sZGVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVsbEZyb21TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNGaWxlKSB7XG4gIGxldCBwYXRoT25TZXJ2ZXI7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7YnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lcjogZHN0UGF0aH0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCxcbiAgICAgIGFzeW5jIChhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpID0+IGF3YWl0IGRldmljZS5zaW1jdGwuZ2V0QXBwQ29udGFpbmVyKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkpO1xuICAgIGxvZy5pbmZvKGBQYXJzZWQgYnVuZGxlIGlkZW50aWZpZXIgJyR7YnVuZGxlSWR9JyBmcm9tICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICBgV2lsbCBnZXQgdGhlIGRhdGEgZnJvbSAnJHtkc3RQYXRofSdgKTtcbiAgICBwYXRoT25TZXJ2ZXIgPSBkc3RQYXRoO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpbVJvb3QgPSBkZXZpY2UuZ2V0RGlyKCk7XG4gICAgcGF0aE9uU2VydmVyID0gcGF0aC5wb3NpeC5qb2luKHNpbVJvb3QsIHJlbW90ZVBhdGgpO1xuICAgIHZlcmlmeUlzU3ViUGF0aChwYXRoT25TZXJ2ZXIsIHNpbVJvb3QpO1xuICAgIGxvZy5pbmZvKGBHb3QgdGhlIGZ1bGwgaXRlbSBwYXRoOiAke3BhdGhPblNlcnZlcn1gKTtcbiAgfVxuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoT25TZXJ2ZXIpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSByZW1vdGUgJHtpc0ZpbGUgPyAnZmlsZScgOiAnZm9sZGVyJ30gYXQgJyR7cGF0aE9uU2VydmVyfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBpc0ZpbGVcbiAgICA/IGF3YWl0IHV0aWwudG9Jbk1lbW9yeUJhc2U2NChwYXRoT25TZXJ2ZXIpXG4gICAgOiBhd2FpdCB6aXAudG9Jbk1lbW9yeVppcChwYXRoT25TZXJ2ZXIsIHtlbmNvZGVUb0Jhc2U2NDogdHJ1ZX0pO1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIHJlYWwgZGV2aWNlIHVuZGVyIHRlc3QgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYCB3aWwgYmUgcHVsbGVkIGludG8gdGhlIG1vdW50ZWQgaG9zdCBtYWNoaW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIEFwcGl1bSByZXR1cm5zIHRoZSBkYXRhIGFzIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBjbGllbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy9gIG1lYW5zIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsZSAtIFdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIGl0ZW0gaXMgYSBmaWxlIG9yIGEgZm9sZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSByZW1vdGUgZmlsZVxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRnJvbVJlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNGaWxlKSB7XG4gIGNvbnN0IHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZUluZm8gPSBhd2FpdCBzZXJ2aWNlLmdldEZpbGVJbmZvKHJlbGF0aXZlUGF0aCk7XG4gICAgaWYgKGlzRmlsZSAmJiBmaWxlSW5mby5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSByZXF1ZXN0ZWQgcGF0aCBpcyBub3QgYSBmaWxlLiBQYXRoOiAnJHtyZW1vdGVQYXRofSdgKTtcbiAgICB9XG4gICAgaWYgKCFpc0ZpbGUgJiYgIWZpbGVJbmZvLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHJlcXVlc3RlZCBwYXRoIGlzIG5vdCBhIGZvbGRlci4gUGF0aDogJyR7cmVtb3RlUGF0aH0nYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGVJbmZvLmlzRmlsZSgpXG4gICAgICA/IChhd2FpdCBwdWxsRmlsZShzZXJ2aWNlLCByZWxhdGl2ZVBhdGgpKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIDogKGF3YWl0IHB1bGxGb2xkZXIoc2VydmljZSwgcmVsYXRpdmVQYXRoKSkudG9TdHJpbmcoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIGRldmljZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhIGZpbGUgb3IgYSBmb2xkZXIsIHdoaWNoIGV4aXN0cyBpbiB0aGUgY29ycmVzcG9uZGluZyBhcHBsaWNhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgb24gU2ltdWxhdG9yLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIGNvbnRhaW5lciB0eXBlcyBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHR5cGUgaXMgJ2FwcCcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZyb21TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYCcke2RzdFBhdGh9JyB3aWxsIGJlIGRlbGV0ZWRgKTtcbiAgICBwYXRoT25TZXJ2ZXIgPSBkc3RQYXRoO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpbVJvb3QgPSBkZXZpY2UuZ2V0RGlyKCk7XG4gICAgcGF0aE9uU2VydmVyID0gcGF0aC5wb3NpeC5qb2luKHNpbVJvb3QsIHJlbW90ZVBhdGgpO1xuICAgIHZlcmlmeUlzU3ViUGF0aChwYXRoT25TZXJ2ZXIsIHNpbVJvb3QpO1xuICAgIGxvZy5pbmZvKGBHb3QgdGhlIGZ1bGwgcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlIHBhdGggYXQgJyR7cGF0aE9uU2VydmVyfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuICBhd2FpdCBmcy5yaW1yYWYocGF0aE9uU2VydmVyKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIGRldmljZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhbiBleGlzdGluZyByZW1vdGUgZmlsZSBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIGRvd25sb2FkZWQgZnJvbSB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9ubHkgc3VwcG9ydGVkIGNvbnRhaW5lciB0eXBlIGlzICdkb2N1bWVudHMnLiBJZiB0aGUgY29udGFpbmVyIHR5cGUgaXMgbm90IHNldFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBsaWNpdGx5IGZvciBhIGJ1bmRsZSBpZCwgdGhlbiB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb250YWluZXIgaXMgZ29pbmcgdG8gYmUgbW91bnRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWthIC0tY29udGFpbmVyIGlmdXNlIGFyZ3VtZW50KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmcuIElmIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvMTExLnBuZ2AgaXMgcHJvdmlkZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YCBpbiBGaWxlcyBhcHAgd2lsbCBiZSBtb3VudGVkIGluIHRoZSBob3N0IG1hY2hpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+LzExMS5wbmdgIHdpbCBiZSBwdWxsZWQgaW50byB0aGUgbW91bnRlZCBob3N0IG1hY2hpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgQXBwaXVtIHJldHVybnMgdGhlIGRhdGEgYXMgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGNsaWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzL2AgbWVhbnMgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRnJvbVJlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCkge1xuICBjb25zdCB7IHNlcnZpY2UsIHJlbGF0aXZlUGF0aCB9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgc2VydmljZS5kZWxldGVEaXJlY3RvcnkocmVsYXRpdmVQYXRoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoT0JKRUNUX05PVF9GT1VORF9FUlJPUl9NRVNTQUdFKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoICcke3JlbW90ZVBhdGh9JyBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgc2VydmljZS5jbG9zZSgpO1xuICB9XG59XG5cbmNvbW1hbmRzLnB1c2hGaWxlID0gYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGUgKHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgaWYgKF8uaXNBcnJheShiYXNlNjREYXRhKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyAoYWhlbSkgamF2YSwgc2VuZCBhIGJ5dGUgYXJyYXkgZW5jb2RpbmcgdXRmOCBjaGFyYWN0ZXJzXG4gICAgLy8gaW5zdGVhZCBvZiBhIHN0cmluZywgd2hpY2ggd291bGQgYmUgaW5maW5pdGVseSBiZXR0ZXIhXG4gICAgYmFzZTY0RGF0YSA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVzaEZpbGVUb1NpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKVxuICAgIDogYXdhaXQgcHVzaEZpbGVUb1JlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSk7XG59O1xuXG5jb21tYW5kcy5wdWxsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIHB1bGxGaWxlIChyZW1vdGVQYXRoKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRydWUpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdHJ1ZSk7XG59O1xuXG5jb21tYW5kcy5tb2JpbGVEZWxldGVGb2xkZXIgPSBhc3luYyBmdW5jdGlvbiBtb2JpbGVEZWxldGVGb2xkZXIgKG9wdHMgPSB7fSkge1xuICBsZXQge3JlbW90ZVBhdGh9ID0gb3B0cztcbiAgaWYgKCFyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICByZW1vdGVQYXRoID0gYCR7cmVtb3RlUGF0aH0vYDtcbiAgfVxuICByZXR1cm4gYXdhaXQgZGVsZXRlRmlsZU9yRm9sZGVyKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRoaXMuaXNTaW11bGF0b3IoKSk7XG59O1xuXG5jb21tYW5kcy5tb2JpbGVEZWxldGVGaWxlID0gYXN5bmMgZnVuY3Rpb24gbW9iaWxlRGVsZXRlRmlsZSAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtyZW1vdGVQYXRofSA9IG9wdHM7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiBhd2FpdCBkZWxldGVGaWxlT3JGb2xkZXIodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdGhpcy5pc1NpbXVsYXRvcigpKTtcbn07XG5cbmNvbW1hbmRzLnB1bGxGb2xkZXIgPSBhc3luYyBmdW5jdGlvbiBwdWxsRm9sZGVyIChyZW1vdGVQYXRoKSB7XG4gIGlmICghcmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmVtb3RlUGF0aCA9IGAke3JlbW90ZVBhdGh9L2A7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVsbEZyb21TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgZmFsc2UpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgZmFsc2UpO1xufTtcblxuZXhwb3J0IHsgY29tbWFuZHMsIC8qIGZvciB0ZXN0aW5nICovIHBhcnNlQ29udGFpbmVyUGF0aCB9O1xuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHM7XG4iXSwiZmlsZSI6ImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
