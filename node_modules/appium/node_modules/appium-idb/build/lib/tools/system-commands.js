"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _teen_process = require("teen_process");

var _lodash = _interopRequireDefault(require("lodash"));

var _asyncbox = require("asyncbox");

var _helpers = require("../helpers");

var _logger = _interopRequireDefault(require("../logger.js"));

const PROCESS_INIT_TIMEOUT = 5000;

const COMPANION_PGREP_PATTERN = udid => `${_helpers.IDB_COMPANION_EXECUTABLE}.*--udid[[:space:]]+${udid}`;

const COMPANION_STARTUP_REGEXP = /Started GRPC server on port (\d+)/;
const COMPANION_STARTUP_ERROR_REGEXP = /New Error Built ==> (.+)/;

function buildDaemonArgs(opts = {}) {
  const {
    port,
    grpcPort
  } = opts;
  const result = ['daemon', '--notifier-path', _helpers.IDB_COMPANION_EXECUTABLE];

  if (port) {
    result.push('--port', port);
  }

  if (grpcPort) {
    result.push('--grpc-port', grpcPort);
  }

  return result;
}

const systemCallMethods = {};

systemCallMethods.connect = async function connect(opts = {}) {
  const {
    onlineTimeout
  } = opts;

  _logger.default.debug(`Connecting ${_helpers.IDB_EXECUTABLE} service to '${this.udid}'`);

  const binaryPaths = {};

  for (const binary of [_helpers.IDB_EXECUTABLE, _helpers.IDB_COMPANION_EXECUTABLE]) {
    try {
      binaryPaths[binary] = await _appiumSupport.fs.which(binary);
    } catch (e) {
      throw new Error(`'${binary}' has not been found in PATH. ` + `Is it installed? Read https://www.fbidb.io for more details`);
    }
  }

  let port = _helpers.DEFAULT_COMPANION_GRPC_PORT;

  try {
    _logger.default.debug(`Starting companion: '${binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE]}'`);

    const companionProc = new _teen_process.SubProcess(binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE], ['--udid', this.udid]);
    companionProc.on('exit', (code, signal) => {
      _logger.default.debug(`Companion exited with code '${code}' from signal '${signal}'`);
    });

    if (this.verbose) {
      companionProc.on('lines-stdout', function (lines) {
        for (let line of lines) {
          line = line.trim();

          if (line) {
            _logger.default.debug(`[Companion stdout] ${line}`);
          }
        }
      });
      companionProc.on('lines-stderr', function (lines) {
        for (let line of lines) {
          line = line.trim();

          if (line) {
            _logger.default.debug(`[Companion stderr] ${line}`);
          }
        }
      });
    }

    await companionProc.start(function (stdout, stderr) {
      const out = stdout || stderr;
      const readyMatch = COMPANION_STARTUP_REGEXP.exec(out);

      if (readyMatch) {
        port = readyMatch[1];
        return true;
      }

      const errorMatch = COMPANION_STARTUP_ERROR_REGEXP.exec(out);

      if (errorMatch) {
        throw new Error(errorMatch[1]);
      }

      return false;
    });
  } catch (err) {
    _logger.default.error(`Failed to start ${_helpers.IDB_COMPANION_EXECUTABLE}: ${err.message}`);

    throw err;
  }

  _logger.default.debug(`Companion running on port '${port}'`);

  try {
    try {
      await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', 'localhost', port]);
    } catch (connectionError) {
      await (0, _asyncbox.retryInterval)(2, 100, async () => {
        await this.disconnect();

        try {
          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['kill']);
        } catch (ign) {}

        let isStartupMonitorEnabled = true;

        try {
          const daemon = new _teen_process.SubProcess(_helpers.IDB_EXECUTABLE, buildDaemonArgs(this.executable));
          let daemonOutput = '';
          daemon.on('output', (stdout, stderr) => {
            if (isStartupMonitorEnabled && _lodash.default.trim(stdout || stderr)) {
              daemonOutput += `[daemon] ${stdout || stderr}\n`;
            }
          });

          try {
            await daemon.start(null, PROCESS_INIT_TIMEOUT);
            await _bluebird.default.delay(300);
          } catch (ign) {}

          if (daemon.isRunning) {
            _logger.default.debug(`${_helpers.IDB_EXECUTABLE} daemon started on port ${this.executable.port || _helpers.DEFAULT_IDB_PORT}`);
          } else {
            if (!daemonOutput.includes('address already in use')) {
              const message = `${_helpers.IDB_EXECUTABLE} daemon has failed to start: ${daemonOutput}`;

              _logger.default.warn(message);

              throw new Error(message);
            }

            _logger.default.debug(`The port ${this.executable.port || _helpers.DEFAULT_IDB_PORT} is already in use. ` + `Assuming it is used by ${_helpers.IDB_EXECUTABLE} daemon`);
          }

          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', this.udid]);
        } catch (connectionError2) {
          if (connectionError2.stderr || connectionError2.stdout) {
            _logger.default.debug(connectionError2.stderr || connectionError2.stdout);
          }

          throw connectionError2;
        } finally {
          isStartupMonitorEnabled = false;
        }
      });
    }
  } catch (e) {
    if (e.stderr) {
      _logger.default.debug(e.stderr);
    }

    throw new Error(`Cannot start ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'. ` + `Check the server log for more details.`);
  }

  _logger.default.info(`Successfully established the connection to ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'`);

  if (onlineTimeout) {
    await this.waitForDevice(onlineTimeout);
  }

  this.executable.path = binaryPaths[_helpers.IDB_EXECUTABLE];
  this.companion.path = binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE];
};

systemCallMethods.waitForDevice = async function waitForDevice(timeoutMs = 10000) {
  if (!timeoutMs) {
    _logger.default.debug('No timeout is provided, so not waiting until the device is online');

    return;
  }

  _logger.default.debug(`Waiting up to ${timeoutMs}ms for the device to be online`);

  const timer = new _appiumSupport.timing.Timer().start();

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        await this.exec(['ui', 'describe-all']);
        return true;
      } catch (e) {
        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 300
    });
  } catch (e) {
    throw new Error(`The device '${this.udid}' is not responding to idb requests after ${timeoutMs}ms timeout. ` + `Original error: ${e.stderr || e.message}`);
  }

  _logger.default.debug(`The device '${this.udid}' is online and ready to accept idb commands in ` + `${timer.getDuration().asSeconds.toFixed(3)}s`);
};

systemCallMethods.disconnect = async function disconnect() {
  _logger.default.debug(`Disconnecting ${_helpers.IDB_EXECUTABLE} service from '${this.udid}'`);

  try {
    await (0, _teen_process.exec)(this.executable.path, ['disconnect', this.udid]);
  } catch (ign) {}

  const companionPids = await (0, _helpers.getPids)(COMPANION_PGREP_PATTERN(this.udid));

  if (_lodash.default.isEmpty(companionPids)) {
    return;
  }

  _logger.default.debug(`Cleaning up ${companionPids.length} obsolete ${_helpers.IDB_COMPANION_EXECUTABLE} ` + `process${companionPids.length === 1 ? '' : 'es'}`);

  await (0, _teen_process.exec)('kill', ['-2', ...companionPids]);
};

systemCallMethods.exec = async function exec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to exec()');
  }

  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.execTimeout || _helpers.DEFAULT_IDB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'execTimeout';
  const args = [...cmd, ...this.executable.defaultArgs];

  _logger.default.debug(`Running '${this.executable.path} ${_appiumSupport.util.quote(args)}'`);

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, args, opts);
    return stdout;
  } catch (e) {
    if (_appiumSupport.util.hasValue(e.code)) {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'; ` + `Stdout: '${(e.stdout || '').trim()}'; ` + `Stderr: '${(e.stderr || '').trim()}'; ` + `Code: '${e.code}'`;
    } else {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms ${_helpers.IDB_EXECUTABLE} execution timeout represented by '${opts.timeoutCapName}' capability`;
    }

    throw e;
  }
};

systemCallMethods.createSubProcess = function createSubProcess(args = [], opts = {}) {
  const idbArgs = [...args, ...this.executable.defaultArgs];

  _logger.default.debug(`Creating ${_helpers.IDB_EXECUTABLE} subprocess with args: ${_appiumSupport.util.quote(args)}`);

  return new _teen_process.SubProcess(this.executable.path, idbArgs, opts);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY29tbWFuZHMuanMiXSwibmFtZXMiOlsiUFJPQ0VTU19JTklUX1RJTUVPVVQiLCJDT01QQU5JT05fUEdSRVBfUEFUVEVSTiIsInVkaWQiLCJJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEUiLCJDT01QQU5JT05fU1RBUlRVUF9SRUdFWFAiLCJDT01QQU5JT05fU1RBUlRVUF9FUlJPUl9SRUdFWFAiLCJidWlsZERhZW1vbkFyZ3MiLCJvcHRzIiwicG9ydCIsImdycGNQb3J0IiwicmVzdWx0IiwicHVzaCIsInN5c3RlbUNhbGxNZXRob2RzIiwiY29ubmVjdCIsIm9ubGluZVRpbWVvdXQiLCJsb2ciLCJkZWJ1ZyIsIklEQl9FWEVDVVRBQkxFIiwiYmluYXJ5UGF0aHMiLCJiaW5hcnkiLCJmcyIsIndoaWNoIiwiZSIsIkVycm9yIiwiREVGQVVMVF9DT01QQU5JT05fR1JQQ19QT1JUIiwiY29tcGFuaW9uUHJvYyIsIlN1YlByb2Nlc3MiLCJvbiIsImNvZGUiLCJzaWduYWwiLCJ2ZXJib3NlIiwibGluZXMiLCJsaW5lIiwidHJpbSIsInN0YXJ0Iiwic3Rkb3V0Iiwic3RkZXJyIiwib3V0IiwicmVhZHlNYXRjaCIsImV4ZWMiLCJlcnJvck1hdGNoIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwiY29ubmVjdGlvbkVycm9yIiwiZGlzY29ubmVjdCIsImlnbiIsImlzU3RhcnR1cE1vbml0b3JFbmFibGVkIiwiZGFlbW9uIiwiZXhlY3V0YWJsZSIsImRhZW1vbk91dHB1dCIsIl8iLCJCIiwiZGVsYXkiLCJpc1J1bm5pbmciLCJERUZBVUxUX0lEQl9QT1JUIiwiaW5jbHVkZXMiLCJ3YXJuIiwiY29ubmVjdGlvbkVycm9yMiIsImluZm8iLCJ3YWl0Rm9yRGV2aWNlIiwicGF0aCIsImNvbXBhbmlvbiIsInRpbWVvdXRNcyIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiY29tcGFuaW9uUGlkcyIsImlzRW1wdHkiLCJsZW5ndGgiLCJjbWQiLCJpc0FycmF5IiwiY2xvbmVEZWVwIiwidGltZW91dCIsImV4ZWNUaW1lb3V0IiwiREVGQVVMVF9JREJfRVhFQ19USU1FT1VUIiwidGltZW91dENhcE5hbWUiLCJhcmdzIiwiZGVmYXVsdEFyZ3MiLCJ1dGlsIiwicXVvdGUiLCJoYXNWYWx1ZSIsImNyZWF0ZVN1YlByb2Nlc3MiLCJpZGJBcmdzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBOztBQUdBLE1BQU1BLG9CQUFvQixHQUFHLElBQTdCOztBQUNBLE1BQU1DLHVCQUF1QixHQUFJQyxJQUFELElBQzdCLEdBQUVDLGlDQUF5Qix1QkFBc0JELElBQUssRUFEekQ7O0FBRUEsTUFBTUUsd0JBQXdCLEdBQUcsbUNBQWpDO0FBQ0EsTUFBTUMsOEJBQThCLEdBQUcsMEJBQXZDOztBQUVBLFNBQVNDLGVBQVQsQ0FBMEJDLElBQUksR0FBRyxFQUFqQyxFQUFxQztBQUNuQyxRQUFNO0FBQ0pDLElBQUFBLElBREk7QUFFSkMsSUFBQUE7QUFGSSxNQUdGRixJQUhKO0FBS0EsUUFBTUcsTUFBTSxHQUFHLENBQ2IsUUFEYSxFQUViLGlCQUZhLEVBRU1QLGlDQUZOLENBQWY7O0FBSUEsTUFBSUssSUFBSixFQUFVO0FBQ1JFLElBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLFFBQVosRUFBc0JILElBQXRCO0FBQ0Q7O0FBQ0QsTUFBSUMsUUFBSixFQUFjO0FBQ1pDLElBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLGFBQVosRUFBMkJGLFFBQTNCO0FBQ0Q7O0FBQ0QsU0FBT0MsTUFBUDtBQUNEOztBQUdELE1BQU1FLGlCQUFpQixHQUFHLEVBQTFCOztBQW9CQUEsaUJBQWlCLENBQUNDLE9BQWxCLEdBQTRCLGVBQWVBLE9BQWYsQ0FBd0JOLElBQUksR0FBRyxFQUEvQixFQUFtQztBQUM3RCxRQUFNO0FB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SUFBWSxFQUFiLEVBQWlCSCxJQUFqQixFQUF3QixLQUYxQixHQUdULFVBQVNYLENBQUMsQ0FBQ00sSUFBSyxHQUhuQjtBQUlELEtBTEQsTUFLTztBQUNMTixNQUFBQSxDQUFDLENBQUNxQixPQUFGLEdBQWEsbUJBQWtCMUIsdUJBQWUsc0JBQXFCSyxDQUFDLENBQUNxQixPQUFRLEtBQWpFLEdBQ1QsdUJBQXNCcEMsSUFBSSxDQUFDdUUsT0FBUSxNQUFLN0QsdUJBQWUsc0NBQXFDVixJQUFJLENBQUMwRSxjQUFlLGNBRG5IO0FBRUQ7O0FBQ0QsVUFBTTNELENBQU47QUFDRDtBQUNGLENBNUJEOztBQXFDQVYsaUJBQWlCLENBQUMyRSxnQkFBbEIsR0FBcUMsU0FBU0EsZ0JBQVQsQ0FBMkJMLElBQUksR0FBRyxFQUFsQyxFQUFzQzNFLElBQUksR0FBRyxFQUE3QyxFQUFpRDtBQUNwRixRQUFNaUYsT0FBTyxHQUFHLENBQUMsR0FBR04sSUFBSixFQUFVLEdBQUcsS0FBS2pDLFVBQUwsQ0FBZ0JrQyxXQUE3QixDQUFoQjs7QUFDQXBFLGtCQUFJQyxLQUFKLENBQVcsWUFBV0MsdUJBQWUsMEJBQXlCbUUsb0JBQUtDLEtBQUwsQ0FBV0gsSUFBWCxDQUFpQixFQUEvRTs7QUFDQSxTQUFPLElBQUl4RCx3QkFBSixDQUFlLEtBQUt1QixVQUFMLENBQWdCWSxJQUEvQixFQUFxQzJCLE9BQXJDLEVBQThDakYsSUFBOUMsQ0FBUDtBQUNELENBSkQ7O2VBTWVLLGlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgZnMsIHV0aWwsIHRpbWluZyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IGV4ZWMgYXMgdHBFeGVjLCBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHtcbiAgZ2V0UGlkcywgREVGQVVMVF9JREJfRVhFQ19USU1FT1VULCBJREJfRVhFQ1VUQUJMRSxcbiAgSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFLCBERUZBVUxUX0lEQl9QT1JULCBERUZBVUxUX0NPTVBBTklPTl9HUlBDX1BPUlQsXG59IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuXG5cbmNvbnN0IFBST0NFU1NfSU5JVF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IENPTVBBTklPTl9QR1JFUF9QQVRURVJOID0gKHVkaWQpID0+XG4gIGAke0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRX0uKi0tdWRpZFtbOnNwYWNlOl1dKyR7dWRpZH1gO1xuY29uc3QgQ09NUEFOSU9OX1NUQVJUVVBfUkVHRVhQID0gL1N0YXJ0ZWQgR1JQQyBzZXJ2ZXIgb24gcG9ydCAoXFxkKykvO1xuY29uc3QgQ09NUEFOSU9OX1NUQVJUVVBfRVJST1JfUkVHRVhQID0gL05ldyBFcnJvciBCdWlsdCA9PT4gKC4rKS87XG5cbmZ1bmN0aW9uIGJ1aWxkRGFlbW9uQXJncyAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwb3J0LFxuICAgIGdycGNQb3J0LFxuICB9ID0gb3B0cztcblxuICBjb25zdCByZXN1bHQgPSBbXG4gICAgJ2RhZW1vbicsXG4gICAgJy0tbm90aWZpZXItcGF0aCcsIElEQl9DT01QQU5JT05fRVhFQ1VUQUJMRSxcbiAgXTtcbiAgaWYgKHBvcnQpIHtcbiAgICByZXN1bHQucHVzaCgnLS1wb3J0JywgcG9ydCk7XG4gIH1cbiAgaWYgKGdycGNQb3J0KSB7XG4gICAgcmVzdWx0LnB1c2goJy0tZ3JwYy1wb3J0JywgZ3JwY1BvcnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuY29uc3Qgc3lzdGVtQ2FsbE1ldGhvZHMgPSB7fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb25uZWN0T3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gb25saW5lVGltZW91dCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqIHVudGlsIHRoZSBkZXZpY2UgdW5kZXIgdGVzdHMgaXMgb25saW5lLiBObyB3YWl0IGlzIGdvaW5nIHRvIGJlIHBlcmZvcm1lZFxuICogaWYgdGhlIHRpbWVvdXQgaXMgbm90IHNldC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gcHJvdmlkZSB0aGlzIHZhbHVlIGlmXG4gKiBgY29ubmVjdGAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGRldmljZSBpcyBib290ZWQsIHNvIG5vdCBhbGwgdGhlIHJlcXVpcmVkXG4gKiBkZXZpY2Ugc2VydmljZXMgaGF2ZSBiZWVuIHN0YXJ0ZWQgeWV0LlxuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgaWRiIGFuZCBjb21wYW5pb24gcHJvY2Vzc2VzIGlmIG5lY2Vzc2FyeSBhbmRcbiAqIGFzc2lnbnMgcGF0aCBwcm9wZXJ0aWVzLiBJdCBpcyBtYW5kYXRvcnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBiZWZvcmVcbiAqIG9uZSBjYW4gc3RhcnQgdXNpbmcgSURCIGluc3RhbmNlLFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBtYW5kYXRvcnkgaWRiIGV4ZWN1dGFibGVzIGFyZSBub3QgcHJlc2VudCBvbiB0aGVcbiAqIGxvY2FsaG9zdCBvciB0aGVyZSB3YXMgYSBmYWlsdXJlIHdoaWxlIHN0YXJ0aW5nL2RldGVjdGluZyB0aGVtXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiBjb25uZWN0IChvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG9ubGluZVRpbWVvdXQsXG4gIH0gPSBvcHRzO1xuXG4gIGxvZy5kZWJ1ZyhgQ29ubmVjdGluZyAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIHRvICcke3RoaXMudWRpZH0nYCk7XG5cbiAgY29uc3QgYmluYXJ5UGF0aHMgPSB7fTtcbiAgZm9yIChjb25zdCBiaW5hcnkgb2YgW0lEQl9FWEVDVVRBQkxFLCBJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJpbmFyeVBhdGhzW2JpbmFyeV0gPSBhd2FpdCBmcy53aGljaChiaW5hcnkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7YmluYXJ5fScgaGFzIG5vdCBiZWVuIGZvdW5kIGluIFBBVEguIGAgK1xuICAgICAgICBgSXMgaXQgaW5zdGFsbGVkPyBSZWFkIGh0dHBzOi8vd3d3LmZiaWRiLmlvIGZvciBtb3JlIGRldGFpbHNgKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcG9ydCA9IERFRkFVTFRfQ09NUEFOSU9OX0dSUENfUE9SVDtcbiAgdHJ5IHtcbiAgICBsb2cuZGVidWcoYFN0YXJ0aW5nIGNvbXBhbmlvbjogJyR7YmluYXJ5UGF0aHNbSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFXX0nYCk7XG4gICAgY29uc3QgY29tcGFuaW9uUHJvYyA9IG5ldyBTdWJQcm9jZXNzKGJpbmFyeVBhdGhzW0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRV0sIFsnLS11ZGlkJywgdGhpcy51ZGlkXSk7XG4gICAgY29tcGFuaW9uUHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ29tcGFuaW9uIGV4aXRlZCB3aXRoIGNvZGUgJyR7Y29kZX0nIGZyb20gc2lnbmFsICcke3NpZ25hbH0nYCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICBjb21wYW5pb25Qcm9jLm9uKCdsaW5lcy1zdGRvdXQnLCBmdW5jdGlvbiAobGluZXMpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBbQ29tcGFuaW9uIHN0ZG91dF0gJHtsaW5lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb21wYW5pb25Qcm9jLm9uKCdsaW5lcy1zdGRlcnInLCBmdW5jdGlvbiAobGluZXMpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBbQ29tcGFuaW9uIHN0ZGVycl0gJHtsaW5lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXdhaXQgY29tcGFuaW9uUHJvYy5zdGFydChmdW5jdGlvbiAoc3Rkb3V0LCBzdGRlcnIpIHtcbiAgICAgIGNvbnN0IG91dCA9IHN0ZG91dCB8fCBzdGRlcnI7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBtYXJrZXIgdGhhdCB0aGluZ3MgYXJlIHJlYWR5IHRvIGdvXG4gICAgICBjb25zdCByZWFkeU1hdGNoID0gQ09NUEFOSU9OX1NUQVJUVVBfUkVHRVhQLmV4ZWMob3V0KTtcbiAgICAgIGlmIChyZWFkeU1hdGNoKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIHBvcnQgYW5kIHNhdmUsIHNvIGlkYiBjYW4gY29ubmVjdFxuICAgICAgICBwb3J0ID0gcmVhZHlNYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGhhcyBiZWVuIGFuIGVycm9yXG4gICAgICBjb25zdCBlcnJvck1hdGNoID0gQ09NUEFOSU9OX1NUQVJUVVBfRVJST1JfUkVHRVhQLmV4ZWMob3V0KTtcbiAgICAgIGlmIChlcnJvck1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1hdGNoWzFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3IoYEZhaWxlZCB0byBzdGFydCAke0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgbG9nLmRlYnVnKGBDb21wYW5pb24gcnVubmluZyBvbiBwb3J0ICcke3BvcnR9J2ApO1xuXG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRwRXhlYyhJREJfRVhFQ1VUQUJMRSwgWydjb25uZWN0JywgJ2xvY2FsaG9zdCcsIHBvcnRdKTtcbiAgICB9IGNhdGNoIChjb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMiwgMTAwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRwRXhlYyhJREJfRVhFQ1VUQUJMRSwgWydraWxsJ10pO1xuICAgICAgICB9IGNhdGNoIChpZ24pIHt9XG4gICAgICAgIGxldCBpc1N0YXJ0dXBNb25pdG9yRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGFlbW9uID0gbmV3IFN1YlByb2Nlc3MoSURCX0VYRUNVVEFCTEUsIGJ1aWxkRGFlbW9uQXJncyh0aGlzLmV4ZWN1dGFibGUpKTtcbiAgICAgICAgICBsZXQgZGFlbW9uT3V0cHV0ID0gJyc7XG4gICAgICAgICAgZGFlbW9uLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1N0YXJ0dXBNb25pdG9yRW5hYmxlZCAmJiBfLnRyaW0oc3Rkb3V0IHx8IHN0ZGVycikpIHtcbiAgICAgICAgICAgICAgZGFlbW9uT3V0cHV0ICs9IGBbZGFlbW9uXSAke3N0ZG91dCB8fCBzdGRlcnJ9XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZGFlbW9uLnN0YXJ0KG51bGwsIFBST0NFU1NfSU5JVF9USU1FT1VUKTtcbiAgICAgICAgICAgIGF3YWl0IEIuZGVsYXkoMzAwKTtcbiAgICAgICAgICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgICAgICAgICBpZiAoZGFlbW9uLmlzUnVubmluZykge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGAke0lEQl9FWEVDVVRBQkxFfSBkYWVtb24gc3RhcnRlZCBvbiBwb3J0ICR7dGhpcy5leGVjdXRhYmxlLnBvcnQgfHwgREVGQVVMVF9JREJfUE9SVH1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkYWVtb25PdXRwdXQuaW5jbHVkZXMoJ2FkZHJlc3MgYWxyZWFkeSBpbiB1c2UnKSkge1xuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7SURCX0VYRUNVVEFCTEV9IGRhZW1vbiBoYXMgZmFpbGVkIHRvIHN0YXJ0OiAke2RhZW1vbk91dHB1dH1gO1xuICAgICAgICAgICAgICBsb2cud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLmRlYnVnKGBUaGUgcG9ydCAke3RoaXMuZXhlY3V0YWJsZS5wb3J0IHx8IERFRkFVTFRfSURCX1BPUlR9IGlzIGFscmVhZHkgaW4gdXNlLiBgICtcbiAgICAgICAgICAgICAgYEFzc3VtaW5nIGl0IGlzIHVzZWQgYnkgJHtJREJfRVhFQ1VUQUJMRX0gZGFlbW9uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHRwRXhlYyhJREJfRVhFQ1VUQUJMRSwgWydjb25uZWN0JywgdGhpcy51ZGlkXSk7XG4gICAgICAgIH0gY2F0Y2ggKGNvbm5lY3Rpb25FcnJvcjIpIHtcbiAgICAgICAgICBpZiAoY29ubmVjdGlvbkVycm9yMi5zdGRlcnIgfHwgY29ubmVjdGlvbkVycm9yMi5zdGRvdXQpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1Zyhjb25uZWN0aW9uRXJyb3IyLnN0ZGVyciB8fCBjb25uZWN0aW9uRXJyb3IyLnN0ZG91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvcjI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaXNTdGFydHVwTW9uaXRvckVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuc3RkZXJyKSB7XG4gICAgICBsb2cuZGVidWcoZS5zdGRlcnIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdGFydCAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIGZvciAnJHt0aGlzLnVkaWR9Jy4gYCArXG4gICAgICBgQ2hlY2sgdGhlIHNlcnZlciBsb2cgZm9yIG1vcmUgZGV0YWlscy5gKTtcbiAgfVxuICBsb2cuaW5mbyhgU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIHRoZSBjb25uZWN0aW9uIHRvICR7SURCX0VYRUNVVEFCTEV9IHNlcnZpY2UgZm9yICcke3RoaXMudWRpZH0nYCk7XG5cbiAgaWYgKG9ubGluZVRpbWVvdXQpIHtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JEZXZpY2Uob25saW5lVGltZW91dCk7XG4gIH1cblxuICB0aGlzLmV4ZWN1dGFibGUucGF0aCA9IGJpbmFyeVBhdGhzW0lEQl9FWEVDVVRBQkxFXTtcbiAgdGhpcy5jb21wYW5pb24ucGF0aCA9IGJpbmFyeVBhdGhzW0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRV07XG59O1xuXG4vKipcbiAqIEJsb2NrcyB1bnRpbCB0aGUgZGV2aWNlIHVuZGVyIHRlc3Qgc3RhcnRzIHJlc3BvbmRpbmcgdG8gaWRiIGNvbW1hbmRzLlxuICogVGhlIGRldmljZSBtdXN0IGJlIGJvb3RlZC9vbmxpbmUgYW5kIGlkYiBtdXN0IGJlIGFscmVhZHkgY29ubmVjdGVkIGZvciB0aGF0IHRvIGhhcHBlblxuICpcbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dE1zIFsxMDAwMF0gLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiB1bnRpbCB0aGUgZGV2aWNlIHVuZGVyIHRlc3RzIGlzIG9ubGluZS4gVGhlIG1ldGhvZCB3aWxsIHJldHVybiBpbW1lZGlhdGVseVxuICogaWYgdGhlIHRpbWVvdXQgaXMgZmFsc3lcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGV2aWNlIGlzIG5vdCByZXNwb25kaW5nIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dFxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRGV2aWNlID0gYXN5bmMgZnVuY3Rpb24gd2FpdEZvckRldmljZSAodGltZW91dE1zID0gMTAwMDApIHtcbiAgaWYgKCF0aW1lb3V0TXMpIHtcbiAgICBsb2cuZGVidWcoJ05vIHRpbWVvdXQgaXMgcHJvdmlkZWQsIHNvIG5vdCB3YWl0aW5nIHVudGlsIHRoZSBkZXZpY2UgaXMgb25saW5lJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nLmRlYnVnKGBXYWl0aW5nIHVwIHRvICR7dGltZW91dE1zfW1zIGZvciB0aGUgZGV2aWNlIHRvIGJlIG9ubGluZWApO1xuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5leGVjKFsndWknLCAnZGVzY3JpYmUtYWxsJ10pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMzAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGV2aWNlICcke3RoaXMudWRpZH0nIGlzIG5vdCByZXNwb25kaW5nIHRvIGlkYiByZXF1ZXN0cyBhZnRlciAke3RpbWVvdXRNc31tcyB0aW1lb3V0LiBgICtcbiAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLnN0ZGVyciB8fCBlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgbG9nLmRlYnVnKGBUaGUgZGV2aWNlICcke3RoaXMudWRpZH0nIGlzIG9ubGluZSBhbmQgcmVhZHkgdG8gYWNjZXB0IGlkYiBjb21tYW5kcyBpbiBgICtcbiAgICBgJHt0aW1lci5nZXREdXJhdGlvbigpLmFzU2Vjb25kcy50b0ZpeGVkKDMpfXNgKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgY2xlYW51cCBvZiBvYnNvbGV0ZSBjb21wYW5pb24gcHJvY2Vzc2VzXG4gKiBUaGUgZGFlbW9uIHByb2Nlc3MgaXMgbGVmdCB1bnRvdWNoZWQsIGJlY2F1c2Uga2lsbGluZyBpdCBtaWdodFxuICogcG90ZW50aWFsbHkgYWZmZWN0IG90aGVyIHBhcmFsbGVsIHNlc3Npb25zLiBOb3RoaW5nXG4gKiBpcyBkb25lIGlmIG5vIG9ic29sZXRlIHByb2Nlc3NlcyBhcmUgZm91bmQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmRpc2Nvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiBkaXNjb25uZWN0ICgpIHtcbiAgbG9nLmRlYnVnKGBEaXNjb25uZWN0aW5nICR7SURCX0VYRUNVVEFCTEV9IHNlcnZpY2UgZnJvbSAnJHt0aGlzLnVkaWR9J2ApO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgdHBFeGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ2Rpc2Nvbm5lY3QnLCB0aGlzLnVkaWRdKTtcbiAgfSBjYXRjaCAoaWduKSB7fVxuXG4gIGNvbnN0IGNvbXBhbmlvblBpZHMgPSBhd2FpdCBnZXRQaWRzKENPTVBBTklPTl9QR1JFUF9QQVRURVJOKHRoaXMudWRpZCkpO1xuICBpZiAoXy5pc0VtcHR5KGNvbXBhbmlvblBpZHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nLmRlYnVnKGBDbGVhbmluZyB1cCAke2NvbXBhbmlvblBpZHMubGVuZ3RofSBvYnNvbGV0ZSAke0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRX0gYCArXG4gICAgYHByb2Nlc3Mke2NvbXBhbmlvblBpZHMubGVuZ3RoID09PSAxID8gJycgOiAnZXMnfWApO1xuICBhd2FpdCB0cEV4ZWMoJ2tpbGwnLCBbJy0yJywgLi4uY29tcGFuaW9uUGlkc10pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBpZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGV4ZWMgKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBleGVjKCknKTtcbiAgfVxuICBjbWQgPSBfLmlzQXJyYXkoY21kKSA/IGNtZCA6IFtjbWRdO1xuXG4gIG9wdHMgPSBfLmNsb25lRGVlcChvcHRzKTtcbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfSURCX0VYRUNfVElNRU9VVDtcbiAgb3B0cy50aW1lb3V0Q2FwTmFtZSA9IG9wdHMudGltZW91dENhcE5hbWUgfHwgJ2V4ZWNUaW1lb3V0JzsgLy8gRm9yIGVycm9yIG1lc3NhZ2VcblxuICBjb25zdCBhcmdzID0gWy4uLmNtZCwgLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzXTtcbiAgbG9nLmRlYnVnKGBSdW5uaW5nICcke3RoaXMuZXhlY3V0YWJsZS5wYXRofSAke3V0aWwucXVvdGUoYXJncyl9J2ApO1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgdHBFeGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBhcmdzLCBvcHRzKTtcbiAgICByZXR1cm4gc3Rkb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHV0aWwuaGFzVmFsdWUoZS5jb2RlKSkge1xuICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyAke0lEQl9FWEVDVVRBQkxFfS4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgYFN0ZG91dDogJyR7KGUuc3Rkb3V0IHx8ICcnKS50cmltKCl9JzsgYCArXG4gICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IGAgK1xuICAgICAgICBgQ29kZTogJyR7ZS5jb2RlfSdgO1xuICAgIH0gZWxzZSB7XG4gICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nICR7SURCX0VYRUNVVEFCTEV9LiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICBgVHJ5IHRvIGluY3JlYXNlIHRoZSAke29wdHMudGltZW91dH1tcyAke0lEQl9FWEVDVVRBQkxFfSBleGVjdXRpb24gdGltZW91dCByZXByZXNlbnRlZCBieSAnJHtvcHRzLnRpbWVvdXRDYXBOYW1lfScgY2FwYWJpbGl0eWA7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTdWJQcm9jZXNzIGluc3RhbmNlIG9mIGlkYiBmb3IgYmFja2dyb3VuZFxuICogZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gYXJncyBhZGRpdGlvbmFsIGlkYiBhcmd1bWVudHNcbiAqIEByZXR1cm5zIHtTdWJQcm9jZXNzfVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jcmVhdGVTdWJQcm9jZXNzID0gZnVuY3Rpb24gY3JlYXRlU3ViUHJvY2VzcyAoYXJncyA9IFtdLCBvcHRzID0ge30pIHtcbiAgY29uc3QgaWRiQXJncyA9IFsuLi5hcmdzLCAuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3NdO1xuICBsb2cuZGVidWcoYENyZWF0aW5nICR7SURCX0VYRUNVVEFCTEV9IHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke3V0aWwucXVvdGUoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgaWRiQXJncywgb3B0cyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbiJdLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jb21tYW5kcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
