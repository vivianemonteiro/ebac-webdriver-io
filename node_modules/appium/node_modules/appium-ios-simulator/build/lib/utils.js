"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SAFARI_STARTUP_TIMEOUT = exports.MOBILE_SAFARI_BUNDLE_ID = void 0;
exports.activateApp = activateApp;
exports.endAllSimulatorDaemons = endAllSimulatorDaemons;
exports.execSQLiteQuery = execSQLiteQuery;
exports.getDeveloperRoot = getDeveloperRoot;
exports.getSimulatorInfo = getSimulatorInfo;
exports.hasSSLCert = hasSSLCert;
exports.installSSLCert = installSSLCert;
exports.killAllSimulators = killAllSimulators;
exports.safeRimRaf = safeRimRaf;
exports.simExists = simExists;
exports.toBiometricDomainComponent = toBiometricDomainComponent;
exports.uninstallSSLCert = uninstallSSLCert;

require("source-map-support/register");

var _logger = _interopRequireDefault(require("./logger"));

var _lodash = _interopRequireDefault(require("lodash"));

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _appiumXcode = require("appium-xcode");

var _nodeSimctl = _interopRequireDefault(require("node-simctl"));

var _appiumSupport = require("appium-support");

var _certificate = require("./certificate");

var _path = _interopRequireDefault(require("path"));

var _simulatorXcode = _interopRequireDefault(require("./simulator-xcode-6"));

const DEFAULT_SIM_SHUTDOWN_TIMEOUT = 30000;
const SAFARI_STARTUP_TIMEOUT = 25 * 1000;
exports.SAFARI_STARTUP_TIMEOUT = SAFARI_STARTUP_TIMEOUT;
const MOBILE_SAFARI_BUNDLE_ID = 'com.apple.mobilesafari';
exports.MOBILE_SAFARI_BUNDLE_ID = MOBILE_SAFARI_BUNDLE_ID;

const APP_ACTIVATION_SCRIPT = pid => `#!/usr/bin/python

from AppKit import NSApplicationActivateIgnoringOtherApps, NSApplicationActivateAllWindows
from Cocoa import NSRunningApplication

app = NSRunningApplication.runningApplicationWithProcessIdentifier_(${pid})
if not app:
    raise ValueError('App with PID ${pid} is not running')
if not app.activateWithOptions_(NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps):
    raise ValueError('App with PID ${pid} cannot be activated')
`;

const BIOMETRICS = {
  touchId: 'fingerTouch',
  faceId: 'pearl'
};

function toBiometricDomainComponent(name) {
  if (!BIOMETRICS[name]) {
    throw new Error(`'${name}' is not a valid biometric. Use one of: ${JSON.stringify(_lodash.default.keys(BIOMETRICS))}`);
  }

  return BIOMETRICS[name];
}

async function pkill(appName, forceKill = false) {
  let args = forceKill ? ['-9'] : [];
  args.push('-x', appName);

  try {
    await (0, _teen_process.exec)('pkill', args);
    return 0;
  } catch (err) {
    if (!_lodash.default.isUndefined(err.code)) {
      throw new Error(`Cannot forcefully terminate ${appName}. pkill error code: ${err.code}`);
    }

    _logger.default.error(`Received unexpected error while trying to kill ${appName}: ${err.message}`);

    throw err;
  }
}

async function killAllSimulators(timeout = DEFAULT_SIM_SHUTDOWN_TIMEOUT) {
  _logger.default.debug('Killing all iOS Simulators');

  const xcodeVersion = await (0, _appiumXcode.getVersion)(true);
  const appName = xcodeVersion.major >= 7 ? 'Simulator' : 'iOS Simulator';
  timeout = timeout * (xcodeVersion.major >= 8 ? 2 : 1);

  try {
    await (0, _teen_process.exec)('xcrun', ['simctl', 'shutdown', xcodeVersion.major > 8 ? 'all' : 'booted'], {
      timeout
    });
  } catch (ign) {}

  const pids = [];

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)('pgrep', ['-f', `${appName}.app/Contents/MacOS/`]);

    if (stdout.trim()) {
      pids.push(...stdout.trim().split(/\s+/));
    }
  } catch (e) {
    if (e.code === 1) {
      _logger.default.debug(`${appName} is not running. Continuing...`);

      return;
    }

    if (_lodash.default.isEmpty(pids)) {
      _logger.default.warn(`pgrep error ${e.code} while detecting whether ${appName} is running. Trying to kill anyway.`);
    }
  }

  if (!_lodash.default.isEmpty(pids)) {
    _logger.default.debug(`Killing processes: ${pids.join(', ')}`);

    try {
      await (0, _teen_process.exec)('kill', ['-9', ...pids.map(pid => `${pid}`)]);
    } catch (ign) {}
  }

  _logger.default.debug(`Using pkill to kill application: ${appName}`);

  try {
    await pkill(appName, true);
  } catch (ign) {}

  let remainingDevices = [];

  async function allSimsAreDown() {
    remainingDevices = [];
    let devices = await new _nodeSimctl.default().getDevices();
    devices = _lodash.default.flatten(_lodash.default.values(devices));
    return _lodash.default.every(devices, sim => {
      let state = sim.state.toLowerCase();
      let done = state === 'shutdown' || state === 'unavailable' || state === 'disconnected';

      if (!done) {
        remainingDevices.push(`${sim.name} (${sim.sdk}, udid: ${sim.udid}) is still in state '${state}'`);
      }

      return done;
    });
  }

  try {
    await (0, _asyncbox.waitForCondition)(allSimsAreDown, {
      waitMs: timeout,
      intervalMs: 200
    });
  } catch (err) {
    if (remainingDevices.length > 0) {
      _logger.default.warn(`The following devices are still not in the correct state after ${timeout} ms:`);

      for (let device of remainingDevices) {
        _logger.default.warn(`    ${device}`);
      }
    }

    throw err;
  }
}

async function endAllSimulatorDaemons() {
  _logger.default.debug('Ending all simulator daemons');

  for (let servicePattern of ['com.apple.iphonesimulator', 'com.apple.CoreSimulator']) {
    _logger.default.debug(`Killing any other ${servicePattern} daemons`);

    let launchCtlCommand = `launchctl list | grep ${servicePattern} | cut -f 3 | xargs -n 1 launchctl`;

    try {
      let stopCmd = `${launchCtlCommand} stop`;
      await (0, _teen_process.exec)('bash', ['-c', stopCmd]);
    } catch (err) {
      _logger.default.warn(`Could not stop ${servicePattern} daemons, carrying on anyway!`);
    }

    try {
      let removeCmd = `${launchCtlCommand} remove`;
      await (0, _teen_process.exec)('bash', ['-c', removeCmd]);
    } catch (err) {
      _logger.default.warn(`Could not remove ${servicePattern} daemons, carrying on anyway!`);
    }
  }

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      let {
        stdout
      } = await (0, _teen_process.exec)('bash', ['-c', `ps -e  | grep launchd_sim | grep -v bash | grep -v grep | awk {'print$1'}`]);
      return stdout.trim().length === 0;
    }, {
      waitMs: 5000,
      intervalMs: 500
    });
  } catch (err) {
    _logger.default.warn(`Could not end all simulator daemons, carrying on!`);
  }

  _logger.default.debug('Finishing ending all simulator daemons');
}

async function getSimulatorInfo(udid, opts = {}) {
  const {
    devicesSetPath
  } = opts;
  let devices = await new _nodeSimctl.default({
    devicesSetPath
  }).getDevices();
  devices = _lodash.default.toPairs(devices).map(pair => pair[1]).reduce((a, b) => a.concat(b), []);
  return _lodash.default.find(devices, sim => sim.udid === udid);
}

async function simExists(udid) {
  return !!(await getSimulatorInfo(udid));
}

async function safeRimRaf(delPath, tryNum = 0) {
  try {
    await _appiumSupport.fs.rimraf(delPath);
  } catch (err) {
    if (tryNum < 20) {
      if (err.message.indexOf('ENOTEMPTY') !== -1) {
        _logger.default.debug(`Path '${delPath}' was not empty during delete; retrying`);

        return await safeRimRaf(delPath, tryNum + 1);
      } else if (err.message.indexOf('ENOENT') !== -1) {
        _logger.default.debug(`Path '${delPath}' did not exist when we tried to delete, ignoring`);

        return await safeRimRaf(delPath, tryNum + 1);
      }
    }
  }
}

async function installSSLCert(pemText, udid) {
  try {
    await _appiumSupport.fs.which('openssl');
  } catch (e) {
    _logger.default.debug(`customSSLCert requires openssl to be available on path`);

    _logger.default.errorAndThrow(`Command 'openssl' not found`);
  }

  try {
    await _appiumSupport.fs.which('sqlite3');
  } catch (e) {
    _logger.default.debug(`customSSLCert requires sqlite3 to be available on path`);

    _logger.default.errorAndThrow(`Command 'sqlite3' not found`);
  }

  let tempFileName = _path.default.resolve(await _appiumSupport.tempDir.openDir(), 'temp-ssl-cert.pem');

  let pathToKeychain = new _simulatorXcode.default(udid).getDir();
  await _appiumSupport.fs.writeFile(tempFileName, pemText);

  try {
    await _appiumSupport.fs.stat(pathToKeychain);
  } catch (e) {
    _logger.default.debug(`Could not install SSL certificate. No simulator with udid '${udid}'`);

    _logger.default.errorAndThrow(e);
  }

  let certificate = new _certificate.Certificate(tempFileName);

  _logger.default.debug(`Installing certificate to ${pathToKeychain}`);

  await certificate.add(pathToKeychain);
  await _appiumSupport.fs.unlink(tempFileName);
  return certificate;
}

async function uninstallSSLCert(pemText, udid) {
  try {
    let tempFileName = _path.default.resolve(__dirname, 'temp-ssl-cert.pem');

    let pathToKeychain = _path.default.resolve(new _simulatorXcode.default(udid).getDir());

    await _appiumSupport.fs.writeFile(tempFileName, pemText);
    let certificate = new _certificate.Certificate(tempFileName);
    await certificate.remove(pathToKeychain);
    await _appiumSupport.fs.unlink(tempFileName);
    return certificate;
  } catch (e) {
    _logger.default.debug(`Could not uninstall SSL certificate. No simulator with udid '${udid}'`);

    _logger.default.errorAndThrow(e);
  }
}

async function hasSSLCert(pemText, udid) {
  const tempFileName = _path.default.resolve(await _appiumSupport.tempDir.openDir(), 'temp-ssl-cert.pem');

  const pathToKeychain = new _simulatorXcode.default(udid).getDir();
  await _appiumSupport.fs.writeFile(tempFileName, pemText);
  const certificate = new _certificate.Certificate(tempFileName);
  return certificate.has(pathToKeychain);
}

async function execSQLiteQuery(db, query, ...queryParams) {
  query = query.replace(/\n+/g, ' ');
  let queryTokens = query.split('?');
  let formattedQuery = [];
  queryParams.map(param => `${param}`).forEach((param, i) => {
    formattedQuery.push(queryTokens[i]);
    formattedQuery.push(param.replace(/'/g, "''"));
  });
  formattedQuery.push(queryTokens[queryTokens.length - 1]);

  _logger.default.debug(`Executing SQL query "${formattedQuery.join('')}" on '${db}'`);

  try {
    return (await (0, _teen_process.exec)('sqlite3', ['-line', db, formattedQuery.join('')])).stdout;
  } catch (err) {
    throw new Error(`Cannot execute SQLite query "${formattedQuery.join('')}" to '${db}'. ` + `Original error: ${err.stderr}`);
  }
}

async function getDeveloperRoot() {
  const {
    stdout
  } = await (0, _teen_process.exec)('xcode-select', ['-p']);
  return stdout.trim();
}

async function activateApp(pid) {
  const tmpScript = await _appiumSupport.tempDir.path({
    prefix: `activate_sim_${_appiumSupport.util.uuidV4().substring(0, 8)}`,
    suffix: '.py'
  });
  await _appiumSupport.fs.writeFile(tmpScript, APP_ACTIVATION_SCRIPT(pid), 'utf8');

  try {
    await (0, _teen_process.exec)('/usr/bin/python', [tmpScript]);
  } finally {
    await _appiumSupport.fs.rimraf(tmpScript);
  }
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91dGlscy5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX1NJTV9TSFVURE9XTl9USU1FT1VUIiwiU0FGQVJJX1NUQVJUVVBfVElNRU9VVCIsIk1PQklMRV9TQUZBUklfQlVORExFX0lEIiwiQVBQX0FDVElWQVRJT05fU0NSSVBUIiwicGlkIiwiQklPTUVUUklDUyIsInRvdWNoSWQiLCJmYWNlSWQiLCJ0b0Jpb21ldHJpY0RvbWFpbkNvbXBvbmVudCIsIm5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJfIiwia2V5cyIsInBraWxsIiwiYXBwTmFtZSIsImZvcmNlS2lsbCIsImFyZ3MiLCJwdXNoIiwiZXJyIiwiaXNVbmRlZmluZWQiLCJjb2RlIiwibG9nIiwiZXJyb3IiLCJtZXNzYWdlIiwia2lsbEFsbFNpbXVsYXRvcnMiLCJ0aW1lb3V0IiwiZGVidWciLCJ4Y29kZVZlcnNpb24iLCJtYWpvciIsImlnbiIsInBpZHMiLCJzdGRvdXQiLCJ0cmltIiwic3BsaXQiLCJlIiwiaXNFbXB0eSIsIndhcm4iLCJqb2luIiwibWFwIiwicmVtYWluaW5nRGV2aWNlcyIsImFsbFNpbXNBcmVEb3duIiwiZGV2aWNlcyIsIlNpbWN0bCIsImdldERldmljZXMiLCJmbGF0dGVuIiwidmFsdWVzIiwiZXZlcnkiLCJzaW0iLCJzdGF0ZSIsInRvTG93ZXJDYXNlIiwiZG9uZSIsInNkayIsInVkaWQiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwibGVuZ3RoIiwiZGV2aWNlIiwiZW5kQWxsU2ltdWxhdG9yRGFlbW9ucyIsInNlcnZpY2VQYXR0ZXJuIiwibGF1bmNoQ3RsQ29tbWFuZCIsInN0b3BDbWQiLCJyZW1vdmVDbWQiLCJnZXRTaW11bGF0b3JJbmZvIiwib3B0cyIsImRldmljZXNTZXRQYXRoIiwidG9QYWlycyIsInBhaXIiLCJyZWR1Y2UiLCJhIiwiYiIsImNvbmNhdCIsImZpbmQiLCJzaW1FeGlzdHMiLCJzYWZlUmltUmFmIiwiZGVsUGF0aCIsInRyeU51bSIsImZzIiwicmltcmFmIiwiaW5kZXhPZiIsImluc3RhbGxTU0xDZXJ0IiwicGVtVGV4dCIsIndoaWNoIiwiZXJyb3JBbmRUaHJvdyIsInRlbXBGaWxlTmFtZSIsInBhdGgiLCJyZXNvbHZlIiwidGVtcERpciIsIm9wZW5EaXIiLCJwYXRoVG9LZXljaGFpbiIsIlNpbXVsYXRvciIsImdldERpciIsIndyaXRlRmlsZSIsInN0YXQiLCJjZXJ0aWZpY2F0ZSIsIkNlcnRpZmljYXRlIiwiYWRkIiwidW5saW5rIiwidW5pbnN0YWxsU1NMQ2VydCIsIl9fZGlybmFtZSIsInJlbW92ZSIsImhhc1NTTENlcnQiLCJoYXMiLCJleGVjU1FMaXRlUXVlcnkiLCJkYiIsInF1ZXJ5IiwicXVlcnlQYXJhbXMiLCJyZXBsYWNlIiwicXVlcnlUb2tlbnMiLCJmb3JtYXR0ZWRRdWVyeSIsInBhcmFtIiwiZm9yRWFjaCIsImkiLCJzdGRlcnIiLCJnZXREZXZlbG9wZXJSb290IiwiYWN0aXZhdGVBcHAiLCJ0bXBTY3JpcHQiLCJwcmVmaXgiLCJ1dGlsIiwidXVpZFY0Iiwic3Vic3RyaW5nIiwic3VmZml4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLDRCQUE0QixHQUFHLEtBQXJDO0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsS0FBSyxJQUFwQzs7QUFDQSxNQUFNQyx1QkFBdUIsR0FBRyx3QkFBaEM7OztBQUNBLE1BQU1DLHFCQUFxQixHQUFJQyxHQUFELElBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0VBLEdBQUk7QUFDMUU7QUFDQSxxQ0FBcUNBLEdBQUk7QUFDekM7QUFDQSxxQ0FBcUNBLEdBQUk7QUFDekMsQ0FWQTs7QUFhQSxNQUFNQyxVQUFVLEdBQUc7QUFDakJDLEVBQUFBLE9BQU8sRUFBRSxhQURRO0FBRWpCQyxFQUFBQSxNQUFNLEVBQUU7QUFGUyxDQUFuQjs7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QUNEOztBQVdELGVBQWVrRixXQUFmLENBQTRCaEgsR0FBNUIsRUFBaUM7QUFDL0IsUUFBTWlILFNBQVMsR0FBRyxNQUFNN0IsdUJBQVFGLElBQVIsQ0FBYTtBQUNuQ2dDLElBQUFBLE1BQU0sRUFBRyxnQkFBZUMsb0JBQUtDLE1BQUwsR0FBY0MsU0FBZCxDQUF3QixDQUF4QixFQUEyQixDQUEzQixDQUE4QixFQURuQjtBQUVuQ0MsSUFBQUEsTUFBTSxFQUFFO0FBRjJCLEdBQWIsQ0FBeEI7QUFJQSxRQUFNNUMsa0JBQUdlLFNBQUgsQ0FBYXdCLFNBQWIsRUFBd0JsSCxxQkFBcUIsQ0FBQ0MsR0FBRCxDQUE3QyxFQUFvRCxNQUFwRCxDQUFOOztBQUNBLE1BQUk7QUFDRixVQUFNLHdCQUFLLGlCQUFMLEVBQXdCLENBQUNpSCxTQUFELENBQXhCLENBQU47QUFDRCxHQUZELFNBRVU7QUFDUixVQUFNdkMsa0JBQUdDLE1BQUgsQ0FBVXNDLFNBQVYsQ0FBTjtBQUNEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBnZXRWZXJzaW9uIH0gZnJvbSAnYXBwaXVtLXhjb2RlJztcbmltcG9ydCBTaW1jdGwgZnJvbSAnbm9kZS1zaW1jdGwnO1xuaW1wb3J0IHsgZnMsIHRlbXBEaXIsIHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSB9IGZyb20gJy4vY2VydGlmaWNhdGUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgU2ltdWxhdG9yIGZyb20gJy4vc2ltdWxhdG9yLXhjb2RlLTYnO1xuXG5cbmNvbnN0IERFRkFVTFRfU0lNX1NIVVRET1dOX1RJTUVPVVQgPSAzMDAwMDtcbmNvbnN0IFNBRkFSSV9TVEFSVFVQX1RJTUVPVVQgPSAyNSAqIDEwMDA7XG5jb25zdCBNT0JJTEVfU0FGQVJJX0JVTkRMRV9JRCA9ICdjb20uYXBwbGUubW9iaWxlc2FmYXJpJztcbmNvbnN0IEFQUF9BQ1RJVkFUSU9OX1NDUklQVCA9IChwaWQpID0+IGAjIS91c3IvYmluL3B5dGhvblxuXG5mcm9tIEFwcEtpdCBpbXBvcnQgTlNBcHBsaWNhdGlvbkFjdGl2YXRlSWdub3JpbmdPdGhlckFwcHMsIE5TQXBwbGljYXRpb25BY3RpdmF0ZUFsbFdpbmRvd3NcbmZyb20gQ29jb2EgaW1wb3J0IE5TUnVubmluZ0FwcGxpY2F0aW9uXG5cbmFwcCA9IE5TUnVubmluZ0FwcGxpY2F0aW9uLnJ1bm5pbmdBcHBsaWNhdGlvbldpdGhQcm9jZXNzSWRlbnRpZmllcl8oJHtwaWR9KVxuaWYgbm90IGFwcDpcbiAgICByYWlzZSBWYWx1ZUVycm9yKCdBcHAgd2l0aCBQSUQgJHtwaWR9IGlzIG5vdCBydW5uaW5nJylcbmlmIG5vdCBhcHAuYWN0aXZhdGVXaXRoT3B0aW9uc18oTlNBcHBsaWNhdGlvbkFjdGl2YXRlQWxsV2luZG93cyB8IE5TQXBwbGljYXRpb25BY3RpdmF0ZUlnbm9yaW5nT3RoZXJBcHBzKTpcbiAgICByYWlzZSBWYWx1ZUVycm9yKCdBcHAgd2l0aCBQSUQgJHtwaWR9IGNhbm5vdCBiZSBhY3RpdmF0ZWQnKVxuYDtcblxuXG5jb25zdCBCSU9NRVRSSUNTID0ge1xuICB0b3VjaElkOiAnZmluZ2VyVG91Y2gnLFxuICBmYWNlSWQ6ICdwZWFybCcsXG59O1xuXG5mdW5jdGlvbiB0b0Jpb21ldHJpY0RvbWFpbkNvbXBvbmVudCAobmFtZSkge1xuICBpZiAoIUJJT01FVFJJQ1NbbmFtZV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSB2YWxpZCBiaW9tZXRyaWMuIFVzZSBvbmUgb2Y6ICR7SlNPTi5zdHJpbmdpZnkoXy5rZXlzKEJJT01FVFJJQ1MpKX1gKTtcbiAgfVxuICByZXR1cm4gQklPTUVUUklDU1tuYW1lXTtcbn1cblxuLy8gcGdyZXAvcGtpbGwgZXhpdCBjb2Rlczpcbi8vIDAgICAgICAgT25lIG9yIG1vcmUgcHJvY2Vzc2VzIHdlcmUgbWF0Y2hlZC5cbi8vIDEgICAgICAgTm8gcHJvY2Vzc2VzIHdlcmUgbWF0Y2hlZC5cbi8vIDIgICAgICAgSW52YWxpZCBvcHRpb25zIHdlcmUgc3BlY2lmaWVkIG9uIHRoZSBjb21tYW5kIGxpbmUuXG4vLyAzICAgICAgIEFuIGludGVybmFsIGVycm9yIG9jY3VycmVkLlxuXG5hc3luYyBmdW5jdGlvbiBwa2lsbCAoYXBwTmFtZSwgZm9yY2VLaWxsID0gZmFsc2UpIHtcbiAgbGV0IGFyZ3MgPSBmb3JjZUtpbGwgPyBbJy05J10gOiBbXTtcbiAgYXJncy5wdXNoKCcteCcsIGFwcE5hbWUpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoJ3BraWxsJywgYXJncyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlcnIuY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZvcmNlZnVsbHkgdGVybWluYXRlICR7YXBwTmFtZX0uIHBraWxsIGVycm9yIGNvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgfVxuICAgIGxvZy5lcnJvcihgUmVjZWl2ZWQgdW5leHBlY3RlZCBlcnJvciB3aGlsZSB0cnlpbmcgdG8ga2lsbCAke2FwcE5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBraWxsQWxsU2ltdWxhdG9ycyAodGltZW91dCA9IERFRkFVTFRfU0lNX1NIVVRET1dOX1RJTUVPVVQpIHtcbiAgbG9nLmRlYnVnKCdLaWxsaW5nIGFsbCBpT1MgU2ltdWxhdG9ycycpO1xuICBjb25zdCB4Y29kZVZlcnNpb24gPSBhd2FpdCBnZXRWZXJzaW9uKHRydWUpO1xuICBjb25zdCBhcHBOYW1lID0geGNvZGVWZXJzaW9uLm1ham9yID49IDcgPyAnU2ltdWxhdG9yJyA6ICdpT1MgU2ltdWxhdG9yJztcblxuICAvLyBsYXRlciB2ZXJzaW9ucyBhcmUgc2xvd2VyIHRvIGNsb3NlXG4gIHRpbWVvdXQgPSB0aW1lb3V0ICogKHhjb2RlVmVyc2lvbi5tYWpvciA+PSA4ID8gMiA6IDEpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYygneGNydW4nLCBbJ3NpbWN0bCcsICdzaHV0ZG93bicsIHhjb2RlVmVyc2lvbi5tYWpvciA+IDggPyAnYWxsJyA6ICdib290ZWQnXSwge3RpbWVvdXR9KTtcbiAgfSBjYXRjaCAoaWduKSB7fVxuXG4gIGNvbnN0IHBpZHMgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3BncmVwJywgWyctZicsIGAke2FwcE5hbWV9LmFwcC9Db250ZW50cy9NYWNPUy9gXSk7XG4gICAgaWYgKHN0ZG91dC50cmltKCkpIHtcbiAgICAgIHBpZHMucHVzaCguLi4oc3Rkb3V0LnRyaW0oKS5zcGxpdCgvXFxzKy8pKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gMSkge1xuICAgICAgbG9nLmRlYnVnKGAke2FwcE5hbWV9IGlzIG5vdCBydW5uaW5nLiBDb250aW51aW5nLi4uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkocGlkcykpIHtcbiAgICAgIGxvZy53YXJuKGBwZ3JlcCBlcnJvciAke2UuY29kZX0gd2hpbGUgZGV0ZWN0aW5nIHdoZXRoZXIgJHthcHBOYW1lfSBpcyBydW5uaW5nLiBUcnlpbmcgdG8ga2lsbCBhbnl3YXkuYCk7XG4gICAgfVxuICB9XG4gIGlmICghXy5pc0VtcHR5KHBpZHMpKSB7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIHByb2Nlc3NlczogJHtwaWRzLmpvaW4oJywgJyl9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWMoJ2tpbGwnLCBbJy05JywgLi4uKHBpZHMubWFwKChwaWQpID0+IGAke3BpZH1gKSldKTtcbiAgICB9IGNhdGNoIChpZ24pIHt9XG4gIH1cblxuICBsb2cuZGVidWcoYFVzaW5nIHBraWxsIHRvIGtpbGwgYXBwbGljYXRpb246ICR7YXBwTmFtZX1gKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwa2lsbChhcHBOYW1lLCB0cnVlKTtcbiAgfSBjYXRjaCAoaWduKSB7fVxuXG4gIC8vIHdhaXQgZm9yIGFsbCB0aGUgZGV2aWNlcyB0byBiZSBzaHV0ZG93biBiZWZvcmUgQ29udGludWluZ1xuICAvLyBidXQgb25seSBwcmludCBvdXQgdGhlIGZhaWxlZCBvbmVzIHdoZW4gdGhleSBhcmUgYWN0dWFsbHkgZnVsbHkgZmFpbGVkXG4gIGxldCByZW1haW5pbmdEZXZpY2VzID0gW107XG4gIGFzeW5jIGZ1bmN0aW9uIGFsbFNpbXNBcmVEb3duICgpIHtcbiAgICByZW1haW5pbmdEZXZpY2VzID0gW107XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCBuZXcgU2ltY3RsKCkuZ2V0RGV2aWNlcygpO1xuICAgIGRldmljZXMgPSBfLmZsYXR0ZW4oXy52YWx1ZXMoZGV2aWNlcykpO1xuICAgIHJldHVybiBfLmV2ZXJ5KGRldmljZXMsIChzaW0pID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IHNpbS5zdGF0ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbGV0IGRvbmUgPSBzdGF0ZSA9PT0gJ3NodXRkb3duJyB8fFxuICAgICAgICAgICAgICAgICBzdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJyB8fFxuICAgICAgICAgICAgICAgICBzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgcmVtYWluaW5nRGV2aWNlcy5wdXNoKGAke3NpbS5uYW1lfSAoJHtzaW0uc2RrfSwgdWRpZDogJHtzaW0udWRpZH0pIGlzIHN0aWxsIGluIHN0YXRlICcke3N0YXRlfSdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lO1xuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhbGxTaW1zQXJlRG93biwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0LFxuICAgICAgaW50ZXJ2YWxNczogMjAwXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChyZW1haW5pbmdEZXZpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZy53YXJuKGBUaGUgZm9sbG93aW5nIGRldmljZXMgYXJlIHN0aWxsIG5vdCBpbiB0aGUgY29ycmVjdCBzdGF0ZSBhZnRlciAke3RpbWVvdXR9IG1zOmApO1xuICAgICAgZm9yIChsZXQgZGV2aWNlIG9mIHJlbWFpbmluZ0RldmljZXMpIHtcbiAgICAgICAgbG9nLndhcm4oYCAgICAke2RldmljZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuZEFsbFNpbXVsYXRvckRhZW1vbnMgKCkge1xuICBsb2cuZGVidWcoJ0VuZGluZyBhbGwgc2ltdWxhdG9yIGRhZW1vbnMnKTtcbiAgZm9yIChsZXQgc2VydmljZVBhdHRlcm4gb2YgWydjb20uYXBwbGUuaXBob25lc2ltdWxhdG9yJywgJ2NvbS5hcHBsZS5Db3JlU2ltdWxhdG9yJ10pIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYW55IG90aGVyICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnNgKTtcbiAgICBsZXQgbGF1bmNoQ3RsQ29tbWFuZCA9IGBsYXVuY2hjdGwgbGlzdCB8IGdyZXAgJHtzZXJ2aWNlUGF0dGVybn0gfCBjdXQgLWYgMyB8IHhhcmdzIC1uIDEgbGF1bmNoY3RsYDtcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3BDbWQgPSBgJHtsYXVuY2hDdGxDb21tYW5kfSBzdG9wYDtcbiAgICAgIGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJywgc3RvcENtZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCBzdG9wICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnMsIGNhcnJ5aW5nIG9uIGFueXdheSFgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZW1vdmVDbWQgPSBgJHtsYXVuY2hDdGxDb21tYW5kfSByZW1vdmVgO1xuICAgICAgYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLCByZW1vdmVDbWRdKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgcmVtb3ZlICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnMsIGNhcnJ5aW5nIG9uIGFueXdheSFgKTtcbiAgICB9XG4gIH1cbiAgLy8gd2FpdGluZyB1bnRpbCB0aGUgc2ltdWxhdG9yIHNlcnZpY2UgaGFzIGRpZWQuXG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsXG4gICAgICAgIGBwcyAtZSAgfCBncmVwIGxhdW5jaGRfc2ltIHwgZ3JlcCAtdiBiYXNoIHwgZ3JlcCAtdiBncmVwIHwgYXdrIHsncHJpbnQkMSd9YF0pO1xuICAgICAgcmV0dXJuIHN0ZG91dC50cmltKCkubGVuZ3RoID09PSAwO1xuICAgIH0sIHt3YWl0TXM6IDUwMDAsIGludGVydmFsTXM6IDUwMH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgQ291bGQgbm90IGVuZCBhbGwgc2ltdWxhdG9yIGRhZW1vbnMsIGNhcnJ5aW5nIG9uIWApO1xuICB9XG4gIGxvZy5kZWJ1ZygnRmluaXNoaW5nIGVuZGluZyBhbGwgc2ltdWxhdG9yIGRhZW1vbnMnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2ltdWxhdG9ySW5mbyAodWRpZCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZXZpY2VzU2V0UGF0aFxuICB9ID0gb3B0cztcbiAgLy8gc2VlIHRoZSBSRUFETUUgZm9yIGdpdGh1Yi5jb20vYXBwaXVtL25vZGUtc2ltY3RsIGZvciBleGFtcGxlIG91dHB1dCBvZiBnZXREZXZpY2VzKClcbiAgbGV0IGRldmljZXMgPSBhd2FpdCBuZXcgU2ltY3RsKHtcbiAgICBkZXZpY2VzU2V0UGF0aFxuICB9KS5nZXREZXZpY2VzKCk7XG5cbiAgZGV2aWNlcyA9IF8udG9QYWlycyhkZXZpY2VzKVxuICAgIC5tYXAoKHBhaXIpID0+IHBhaXJbMV0pXG4gICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgcmV0dXJuIF8uZmluZChkZXZpY2VzLCAoc2ltKSA9PiBzaW0udWRpZCA9PT0gdWRpZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNpbUV4aXN0cyAodWRpZCkge1xuICByZXR1cm4gISEoYXdhaXQgZ2V0U2ltdWxhdG9ySW5mbyh1ZGlkKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhZmVSaW1SYWYgKGRlbFBhdGgsIHRyeU51bSA9IDApIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYoZGVsUGF0aCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0cnlOdW0gPCAyMCkge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0VOT1RFTVBUWScpICE9PSAtMSkge1xuICAgICAgICBsb2cuZGVidWcoYFBhdGggJyR7ZGVsUGF0aH0nIHdhcyBub3QgZW1wdHkgZHVyaW5nIGRlbGV0ZTsgcmV0cnlpbmdgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNhZmVSaW1SYWYoZGVsUGF0aCwgdHJ5TnVtICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0VOT0VOVCcpICE9PSAtMSkge1xuICAgICAgICBsb2cuZGVidWcoYFBhdGggJyR7ZGVsUGF0aH0nIGRpZCBub3QgZXhpc3Qgd2hlbiB3ZSB0cmllZCB0byBkZWxldGUsIGlnbm9yaW5nYCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzYWZlUmltUmFmKGRlbFBhdGgsIHRyeU51bSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluc3RhbGwgYW4gU1NMIGNlcnRpZmljYXRlIHRvIGEgZGV2aWNlIHdpdGggZ2l2ZW4gdWRpZFxuICogQHBhcmFtIHtzdHJpbmd9IHBlbVRleHQgU1NMIHBlbSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBJZGVudGlmaWVyIG9mIHRoZSBTaW11bGF0b3JcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5zdGFsbFNTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgLy8gQ2hlY2sgdGhhdCBvcGVuc3NsIGlzIGluc3RhbGxlZCBvbiB0aGUgcGF0aFxuICB0cnkge1xuICAgIGF3YWl0IGZzLndoaWNoKCdvcGVuc3NsJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoYGN1c3RvbVNTTENlcnQgcmVxdWlyZXMgb3BlbnNzbCB0byBiZSBhdmFpbGFibGUgb24gcGF0aGApO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb21tYW5kICdvcGVuc3NsJyBub3QgZm91bmRgKTtcbiAgfVxuXG4gIC8vIENoZWNrIHRoYXQgc3FsaXRlMyBpcyBpbnN0YWxsZWQgb24gdGhlIHBhdGhcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53aGljaCgnc3FsaXRlMycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBjdXN0b21TU0xDZXJ0IHJlcXVpcmVzIHNxbGl0ZTMgdG8gYmUgYXZhaWxhYmxlIG9uIHBhdGhgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ29tbWFuZCAnc3FsaXRlMycgbm90IGZvdW5kYCk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZmlsZSB0byBzdG9yZSBQRU0gdGV4dFxuICAvLyAoYSB0ZW1wIGZpbGUgaXMgbmVjZXNzYXJ5IHRvIHJ1biBgb3BlbnNzbGAgc2hlbGwgY29tbWFuZHMsIGNhbid0IGJlIGRvbmUgaW4gbWVtb3J5KVxuICBsZXQgdGVtcEZpbGVOYW1lID0gcGF0aC5yZXNvbHZlKGF3YWl0IHRlbXBEaXIub3BlbkRpcigpLCAndGVtcC1zc2wtY2VydC5wZW0nKTtcbiAgbGV0IHBhdGhUb0tleWNoYWluID0gbmV3IFNpbXVsYXRvcih1ZGlkKS5nZXREaXIoKTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBGaWxlTmFtZSwgcGVtVGV4dCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMuc3RhdChwYXRoVG9LZXljaGFpbik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoYENvdWxkIG5vdCBpbnN0YWxsIFNTTCBjZXJ0aWZpY2F0ZS4gTm8gc2ltdWxhdG9yIHdpdGggdWRpZCAnJHt1ZGlkfSdgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgfVxuXG4gIC8vIERvIHRoZSBjZXJ0aWZpY2F0ZSBpbnN0YWxsYXRpb25cbiAgbGV0IGNlcnRpZmljYXRlID0gbmV3IENlcnRpZmljYXRlKHRlbXBGaWxlTmFtZSk7XG4gIGxvZy5kZWJ1ZyhgSW5zdGFsbGluZyBjZXJ0aWZpY2F0ZSB0byAke3BhdGhUb0tleWNoYWlufWApO1xuICBhd2FpdCBjZXJ0aWZpY2F0ZS5hZGQocGF0aFRvS2V5Y2hhaW4pO1xuXG4gIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGZpbGVcbiAgYXdhaXQgZnMudW5saW5rKHRlbXBGaWxlTmFtZSk7XG5cbiAgcmV0dXJuIGNlcnRpZmljYXRlO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bmluc3RhbGxTU0xDZXJ0IChwZW1UZXh0LCB1ZGlkKSB7XG4gIHRyeSB7XG4gICAgbGV0IHRlbXBGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICd0ZW1wLXNzbC1jZXJ0LnBlbScpO1xuICAgIGxldCBwYXRoVG9LZXljaGFpbiA9IHBhdGgucmVzb2x2ZShuZXcgU2ltdWxhdG9yKHVkaWQpLmdldERpcigpKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodGVtcEZpbGVOYW1lLCBwZW1UZXh0KTtcbiAgICBsZXQgY2VydGlmaWNhdGUgPSBuZXcgQ2VydGlmaWNhdGUodGVtcEZpbGVOYW1lKTtcbiAgICBhd2FpdCBjZXJ0aWZpY2F0ZS5yZW1vdmUocGF0aFRvS2V5Y2hhaW4pO1xuICAgIGF3YWl0IGZzLnVubGluayh0ZW1wRmlsZU5hbWUpO1xuICAgIHJldHVybiBjZXJ0aWZpY2F0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgQ291bGQgbm90IHVuaW5zdGFsbCBTU0wgY2VydGlmaWNhdGUuIE5vIHNpbXVsYXRvciB3aXRoIHVkaWQgJyR7dWRpZH0nYCk7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgU2ltdWxhdG9yIGFscmVhZHkgaGFzIHRoaXMgU1NMIGNlcnRpZmljYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVtVGV4dCBQRU0gdGV4dCBvZiBTU0wgY2VydFxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgSWRlbnRpZmllciBvZiB0aGUgU2ltdWxhdG9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc1NTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgY29uc3QgdGVtcEZpbGVOYW1lID0gcGF0aC5yZXNvbHZlKGF3YWl0IHRlbXBEaXIub3BlbkRpcigpLCAndGVtcC1zc2wtY2VydC5wZW0nKTtcbiAgY29uc3QgcGF0aFRvS2V5Y2hhaW4gPSBuZXcgU2ltdWxhdG9yKHVkaWQpLmdldERpcigpO1xuICBhd2FpdCBmcy53cml0ZUZpbGUodGVtcEZpbGVOYW1lLCBwZW1UZXh0KTtcbiAgY29uc3QgY2VydGlmaWNhdGUgPSBuZXcgQ2VydGlmaWNhdGUodGVtcEZpbGVOYW1lKTtcbiAgcmV0dXJuIGNlcnRpZmljYXRlLmhhcyhwYXRoVG9LZXljaGFpbik7XG59XG5cbi8qKlxuICogUnVucyBhIGNvbW1hbmQgbGluZSBzcWxpdGUzIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRiIC0gRnVsbCBwYXRoIHRvIHNxbGl0ZSBkYXRhYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGFjdHVhbCBxdWVyeSBzdHJpbmdcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBxdWVyeVBhcmFtcyAtIFRoZSBsaXN0IG9mIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHNxbGl0ZSBjb21tYW5kIHN0ZG91dFxuICovXG5hc3luYyBmdW5jdGlvbiBleGVjU1FMaXRlUXVlcnkgKGRiLCBxdWVyeSwgLi4ucXVlcnlQYXJhbXMpIHtcbiAgcXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9cXG4rL2csICcgJyk7XG4gIGxldCBxdWVyeVRva2VucyA9IHF1ZXJ5LnNwbGl0KCc/Jyk7XG4gIGxldCBmb3JtYXR0ZWRRdWVyeSA9IFtdO1xuICBxdWVyeVBhcmFtc1xuICAgIC5tYXAoKHBhcmFtKSA9PiBgJHtwYXJhbX1gKVxuICAgIC5mb3JFYWNoKChwYXJhbSwgaSkgPT4ge1xuICAgICAgZm9ybWF0dGVkUXVlcnkucHVzaChxdWVyeVRva2Vuc1tpXSk7XG4gICAgICBmb3JtYXR0ZWRRdWVyeS5wdXNoKHBhcmFtLnJlcGxhY2UoLycvZywgXCInJ1wiKSk7XG4gICAgfSk7XG4gIGZvcm1hdHRlZFF1ZXJ5LnB1c2gocXVlcnlUb2tlbnNbcXVlcnlUb2tlbnMubGVuZ3RoIC0gMV0pO1xuXG4gIGxvZy5kZWJ1ZyhgRXhlY3V0aW5nIFNRTCBxdWVyeSBcIiR7Zm9ybWF0dGVkUXVlcnkuam9pbignJyl9XCIgb24gJyR7ZGJ9J2ApO1xuICB0cnkge1xuICAgIHJldHVybiAoYXdhaXQgZXhlYygnc3FsaXRlMycsIFsnLWxpbmUnLCBkYiwgZm9ybWF0dGVkUXVlcnkuam9pbignJyldKSkuc3Rkb3V0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBleGVjdXRlIFNRTGl0ZSBxdWVyeSBcIiR7Zm9ybWF0dGVkUXVlcnkuam9pbignJyl9XCIgdG8gJyR7ZGJ9Jy4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLnN0ZGVycn1gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXREZXZlbG9wZXJSb290ICgpIHtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y29kZS1zZWxlY3QnLCBbJy1wJ10pO1xuICByZXR1cm4gc3Rkb3V0LnRyaW0oKTtcbn1cblxuLyoqXG4gKiBBY3RpdmF0ZXMgdGhlIGFwcCBoYXZpbmcgdGhlIGdpdmVuIHByb2Nlc3MgaWRlbnRpZmllci5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZG9jdW1lbnRhdGlvbi9hcHBraXQvbnNydW5uaW5nYXBwbGljYXRpb24vMTUyODcyNS1hY3RpdmF0ZXdpdGhvcHRpb25zP2xhbmd1YWdlPW9iamNcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBwaWQgQXBwIHByb2Nlc3MgaWRlbnRpZmllclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBnaXZlbiBQSUQgaXMgbm90IHJ1bm5pbmcgb3IgdGhlcmUgd2FzIGEgZmFpbHVyZVxuICogd2hpbGUgYWN0aXZhdGluZyB0aGUgYXBwXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFjdGl2YXRlQXBwIChwaWQpIHtcbiAgY29uc3QgdG1wU2NyaXB0ID0gYXdhaXQgdGVtcERpci5wYXRoKHtcbiAgICBwcmVmaXg6IGBhY3RpdmF0ZV9zaW1fJHt1dGlsLnV1aWRWNCgpLnN1YnN0cmluZygwLCA4KX1gLFxuICAgIHN1ZmZpeDogJy5weScsXG4gIH0pO1xuICBhd2FpdCBmcy53cml0ZUZpbGUodG1wU2NyaXB0LCBBUFBfQUNUSVZBVElPTl9TQ1JJUFQocGlkKSwgJ3V0ZjgnKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKCcvdXNyL2Jpbi9weXRob24nLCBbdG1wU2NyaXB0XSk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFNjcmlwdCk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAga2lsbEFsbFNpbXVsYXRvcnMsXG4gIGVuZEFsbFNpbXVsYXRvckRhZW1vbnMsXG4gIHNhZmVSaW1SYWYsXG4gIHNpbUV4aXN0cyxcbiAgZ2V0U2ltdWxhdG9ySW5mbyxcbiAgaW5zdGFsbFNTTENlcnQsXG4gIHVuaW5zdGFsbFNTTENlcnQsXG4gIGhhc1NTTENlcnQsXG4gIGV4ZWNTUUxpdGVRdWVyeSxcbiAgdG9CaW9tZXRyaWNEb21haW5Db21wb25lbnQsXG4gIGdldERldmVsb3BlclJvb3QsXG4gIGFjdGl2YXRlQXBwLFxuICBTQUZBUklfU1RBUlRVUF9USU1FT1VULFxuICBNT0JJTEVfU0FGQVJJX0JVTkRMRV9JRCxcbn07XG4iXSwiZmlsZSI6ImxpYi91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
