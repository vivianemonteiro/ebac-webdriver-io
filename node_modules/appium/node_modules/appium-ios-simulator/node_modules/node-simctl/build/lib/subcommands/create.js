"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireWildcard(require("../logger"));

var _asyncbox = require("asyncbox");

var _helpers = require("../helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SIM_RUNTIME_NAME_SUFFIX_IOS = 'iOS';
const DEFAULT_CREATE_SIMULATOR_TIMEOUT = 10000;
const commands = {};

commands.createDevice = async function createDevice(name, deviceTypeId, platformVersion, opts = {}) {
  const {
    platform = SIM_RUNTIME_NAME_SUFFIX_IOS,
    timeout = DEFAULT_CREATE_SIMULATOR_TIMEOUT
  } = opts;
  let runtimeIds = [];

  try {
    runtimeIds.push(await this.getRuntimeForPlatformVersionViaJson(platformVersion, platform));
  } catch (ign) {}

  if (_lodash.default.isEmpty(runtimeIds)) {
    let runtimeId;

    try {
      runtimeId = await this.getRuntimeForPlatformVersion(platformVersion, platform);
    } catch (err) {
      _logger.default.warn(`Unable to find runtime for iOS '${platformVersion}'. Continuing`);

      runtimeId = platformVersion;
    }

    let potentialRuntimeIds = [(0, _helpers.normalizeVersion)(runtimeId)];

    if (runtimeId.split('.').length === 3) {
      potentialRuntimeIds.push(runtimeId);
    }

    runtimeIds.push(...potentialRuntimeIds.map(id => `${_helpers.SIM_RUNTIME_NAME}${platform}-${id.replace(/\./g, '-')}`), ...potentialRuntimeIds);
  }

  let udid;

  for (const runtimeId of runtimeIds) {
    _logger.default.debug(_logger.LOG_PREFIX, `Creating simulator with name '${name}', device type id '${deviceTypeId}' and runtime id '${runtimeId}'`);

    try {
      const {
        stdout
      } = await this.exec('create', {
        args: [name, deviceTypeId, runtimeId]
      });
      udid = stdout.trim();
      break;
    } catch (ign) {}
  }

  if (!udid) {
    throw new Error(`Could not create simulator with name '${name}', device ` + `type id '${deviceTypeId}', with runtime ids ` + `${runtimeIds.map(id => `'${id}'`).join(', ')}`);
  }

  const retries = parseInt(timeout / 1000, 10);
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    const devices = _lodash.default.values(await this.getDevices());

    for (const deviceArr of _lodash.default.values(devices)) {
      for (const device of deviceArr) {
        if (device.udid === udid) {
          if (device.state === 'Creating') {
            throw new Error(`Device with udid '${udid}' still being created`);
          } else {
            return;
          }
        }
      }
    }

    throw new Error(`Device with udid '${udid}' not yet created`);
  });
  return udid;
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zdWJjb21tYW5kcy9jcmVhdGUuanMiXSwibmFtZXMiOlsiU0lNX1JVTlRJTUVfTkFNRV9TVUZGSVhfSU9TIiwiREVGQVVMVF9DUkVBVEVfU0lNVUxBVE9SX1RJTUVPVVQiLCJjb21tYW5kcyIsImNyZWF0ZURldmljZSIsIm5hbWUiLCJkZXZpY2VUeXBlSWQiLCJwbGF0Zm9ybVZlcnNpb24iLCJvcHRzIiwicGxhdGZvcm0iLCJ0aW1lb3V0IiwicnVudGltZUlkcyIsInB1c2giLCJnZXRSdW50aW1lRm9yUGxhdGZvcm1WZXJzaW9uVmlhSnNvbiIsImlnbiIsIl8iLCJpc0VtcHR5IiwicnVudGltZUlkIiwiZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbiIsImVyciIsImxvZyIsIndhcm4iLCJwb3RlbnRpYWxSdW50aW1lSWRzIiwic3BsaXQiLCJsZW5ndGgiLCJtYXAiLCJpZCIsIlNJTV9SVU5USU1FX05BTUUiLCJyZXBsYWNlIiwidWRpZCIsImRlYnVnIiwiTE9HX1BSRUZJWCIsInN0ZG91dCIsImV4ZWMiLCJhcmdzIiwidHJpbSIsIkVycm9yIiwiam9pbiIsInJldHJpZXMiLCJwYXJzZUludCIsImRldmljZXMiLCJ2YWx1ZXMiLCJnZXREZXZpY2VzIiwiZGV2aWNlQXJyIiwiZGV2aWNlIiwic3RhdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLE1BQU1BLDJCQUEyQixHQUFHLEtBQXBDO0FBQ0EsTUFBTUMsZ0NBQWdDLEdBQUcsS0FBekM7QUFFQSxNQUFNQyxRQUFRLEdBQUcsRUFBakI7O0FBcUJBQSxRQUFRLENBQUNDLFlBQVQsR0FBd0IsZUFBZUEsWUFBZixDQUE2QkMsSUFBN0IsRUFBbUNDLFlBQW5DLEVBQWlEQyxlQUFqRCxFQUFrRUMsSUFBSSxHQUFHLEVBQXpFLEVBQTZFO0FBQ25HLFFBQU07QUFDSkMsSUFBQUEsUUFBUSxHQUFHUiwyQkFEUDtBQUVKUyxJQUFBQSxPQUFPLEdB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LHVCQUFwQyxDQUFOO0FBQ0QsV0FIRCxNQUdPO0FBRUw7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFDRCxVQUFNLElBQUlPLEtBQUosQ0FBVyxxQkFBb0JQLElBQUssbUJBQXBDLENBQU47QUFDRCxHQWhCSyxDQUFOO0FBa0JBLFNBQU9BLElBQVA7QUFDRCxDQXBGRDs7ZUFzRmUxQixRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2csIHsgTE9HX1BSRUZJWCB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgU0lNX1JVTlRJTUVfTkFNRSwgbm9ybWFsaXplVmVyc2lvbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5cbmNvbnN0IFNJTV9SVU5USU1FX05BTUVfU1VGRklYX0lPUyA9ICdpT1MnO1xuY29uc3QgREVGQVVMVF9DUkVBVEVfU0lNVUxBVE9SX1RJTUVPVVQgPSAxMDAwMDtcblxuY29uc3QgY29tbWFuZHMgPSB7fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaW1DcmVhdGlvbk9wdHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbGF0Zm9ybSBbaU9TXSAtIFBsYXRmb3JtIG5hbWUgaW4gb3JkZXIgdG8gc3BlY2lmeSBydW50aW1lIHN1Y2ggYXMgJ2lPUycsICd0dk9TJywgJ3dhdGNoT1MnXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dCBbMTAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdCBkZXZpY2UgY3JlYXRpb24gaXMgY29tcGxldGVkLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIFNpbXVsYXRvciBkZXZpY2Ugd2l0aCBnaXZlbiBuYW1lIGZvciB0aGUgcGFydGljdWxhclxuICogcGxhdGZvcm0gdHlwZSBhbmQgdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkZXZpY2UgbmFtZSB0byBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGRldmljZVR5cGVJZCAtIERldmljZSB0eXBlLCBmb3IgZXhhbXBsZSAnaVBob25lIDYnLlxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtVmVyc2lvbiAtIFBsYXRmb3JtIHZlcnNpb24sIGZvciBleGFtcGxlICcxMC4zJy5cbiAqIEBwYXJhbSB7P1NpbUNyZWF0aW9uT3B0c30gb3B0cyAtIFNpbXVsYXRvciBvcHRpb25zIGZvciBjcmVhdGluZyBkZXZpY2VzLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgVURJRCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBkZXZpY2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgc2ltY3RsIHN1YmNvbW1hbmQgY29tbWFuZFxuICogICAgICAgICAgICAgICAgIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbmNvbW1hbmRzLmNyZWF0ZURldmljZSA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURldmljZSAobmFtZSwgZGV2aWNlVHlwZUlkLCBwbGF0Zm9ybVZlcnNpb24sIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGxhdGZvcm0gPSBTSU1fUlVOVElNRV9OQU1FX1NVRkZJWF9JT1MsXG4gICAgdGltZW91dCA9IERFRkFVTFRfQ1JFQVRFX1NJTVVMQVRPUl9USU1FT1VUXG4gIH0gPSBvcHRzO1xuXG4gIGxldCBydW50aW1lSWRzID0gW107XG5cbiAgLy8gVHJ5IGdldHRpbmcgcnVudGltZUlkIHVzaW5nIEpTT04gZmxhZ1xuICB0cnkge1xuICAgIHJ1bnRpbWVJZHMucHVzaChhd2FpdCB0aGlzLmdldFJ1bnRpbWVGb3JQbGF0Zm9ybVZlcnNpb25WaWFKc29uKHBsYXRmb3JtVmVyc2lvbiwgcGxhdGZvcm0pKTtcbiAgfSBjYXRjaCAoaWduKSB7fVxuXG4gIGlmIChfLmlzRW1wdHkocnVudGltZUlkcykpIHtcbiAgICAvLyBhdCBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgcnVudGltZSBpZCBpcyB0aGUgcmlnaHQgb25lXG4gICAgLy8gaW4gc29tZSB2ZXJzaW9ucyBvZiBYY29kZSBpdCB3aWxsIGJlIGEgcGF0Y2ggdmVyc2lvblxuICAgIGxldCBydW50aW1lSWQ7XG4gICAgdHJ5IHtcbiAgICAgIHJ1bnRpbWVJZCA9IGF3YWl0IHRoaXMuZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbihwbGF0Zm9ybVZlcnNpb24sIHBsYXRmb3JtKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gZmluZCBydW50aW1lIGZvciBpT1MgJyR7cGxhdGZvcm1WZXJzaW9ufScuIENvbnRpbnVpbmdgKTtcbiAgICAgIHJ1bnRpbWVJZCA9IHBsYXRmb3JtVmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHBvc3NpYmxlIHJ1bnRpbWVzLCB3aGljaCB3aWxsIGJlIGl0ZXJhdGVkIG92ZXJcblxuICAgIC8vIHN0YXJ0IHdpdGggbWFqb3ItbWlub3IgdmVyc2lvblxuICAgIGxldCBwb3RlbnRpYWxSdW50aW1lSWRzID0gW25vcm1hbGl6ZVZlcnNpb24ocnVudGltZUlkKV07XG4gICAgaWYgKHJ1bnRpbWVJZC5zcGxpdCgnLicpLmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gYWRkIHBhdGNoIHZlcnNpb24gaWYgaXQgZXhpc3RzXG4gICAgICBwb3RlbnRpYWxSdW50aW1lSWRzLnB1c2gocnVudGltZUlkKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbW9kaWZpZWQgdmVyc2lvbnMsIHNpbmNlIG1vZGVybiBYY29kZXMgdXNlIHRoaXMsIHRoZW4gdGhlIGJhcmVcbiAgICAvLyB2ZXJzaW9ucywgdG8gYWNjb21vZGF0ZSBvbGRlciBYY29kZXNcbiAgICBydW50aW1lSWRzLnB1c2goXG4gICAgICAuLi4ocG90ZW50aWFsUnVudGltZUlkcy5tYXAoKGlkKSA9PiBgJHtTSU1fUlVOVElNRV9OQU1FfSR7cGxhdGZvcm19LSR7aWQucmVwbGFjZSgvXFwuL2csICctJyl9YCkpLFxuICAgICAgLi4ucG90ZW50aWFsUnVudGltZUlkc1xuICAgICk7XG4gIH1cblxuICAvLyBnbyB0aHJvdWdoIHRoZSBydW50aW1lIGlkcyBhbmQgdHJ5IHRvIGNyZWF0ZSBhIHNpbXVsYXRvciB3aXRoIGVhY2hcbiAgbGV0IHVkaWQ7XG4gIGZvciAoY29uc3QgcnVudGltZUlkIG9mIHJ1bnRpbWVJZHMpIHtcbiAgICBsb2cuZGVidWcoTE9HX1BSRUZJWCxcbiAgICAgIGBDcmVhdGluZyBzaW11bGF0b3Igd2l0aCBuYW1lICcke25hbWV9JywgZGV2aWNlIHR5cGUgaWQgJyR7ZGV2aWNlVHlwZUlkfScgYW5kIHJ1bnRpbWUgaWQgJyR7cnVudGltZUlkfSdgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWMoJ2NyZWF0ZScsIHtcbiAgICAgICAgYXJnczogW25hbWUsIGRldmljZVR5cGVJZCwgcnVudGltZUlkXVxuICAgICAgfSk7XG4gICAgICB1ZGlkID0gc3Rkb3V0LnRyaW0oKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKGlnbikge1xuICAgICAgLy8gdGhlIGVycm9yIGdldHMgbG9nZ2VkIGluIGBzaW1FeGVjYFxuICAgIH1cbiAgfVxuXG4gIGlmICghdWRpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBzaW11bGF0b3Igd2l0aCBuYW1lICcke25hbWV9JywgZGV2aWNlIGAgK1xuICAgICAgYHR5cGUgaWQgJyR7ZGV2aWNlVHlwZUlkfScsIHdpdGggcnVudGltZSBpZHMgYCArXG4gICAgICBgJHtydW50aW1lSWRzLm1hcCgoaWQpID0+IGAnJHtpZH0nYCkuam9pbignLCAnKX1gKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IGl0IGdldHMgb3V0IG9mIHRoZSBcIkNyZWF0aW5nXCIgc3RhdGVcbiAgY29uc3QgcmV0cmllcyA9IHBhcnNlSW50KHRpbWVvdXQgLyAxMDAwLCAxMCk7XG4gIGF3YWl0IHJldHJ5SW50ZXJ2YWwocmV0cmllcywgMTAwMCwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGRldmljZXMgPSBfLnZhbHVlcyhhd2FpdCB0aGlzLmdldERldmljZXMoKSk7XG4gICAgZm9yIChjb25zdCBkZXZpY2VBcnIgb2YgXy52YWx1ZXMoZGV2aWNlcykpIHtcbiAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIGRldmljZUFycikge1xuICAgICAgICBpZiAoZGV2aWNlLnVkaWQgPT09IHVkaWQpIHtcbiAgICAgICAgICBpZiAoZGV2aWNlLnN0YXRlID09PSAnQ3JlYXRpbmcnKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJldHJ5XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERldmljZSB3aXRoIHVkaWQgJyR7dWRpZH0nIHN0aWxsIGJlaW5nIGNyZWF0ZWRgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcCBsb29raW5nLCB3ZSdyZSBkb25lXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgRGV2aWNlIHdpdGggdWRpZCAnJHt1ZGlkfScgbm90IHlldCBjcmVhdGVkYCk7XG4gIH0pO1xuXG4gIHJldHVybiB1ZGlkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHM7XG4iXSwiZmlsZSI6ImxpYi9zdWJjb21tYW5kcy9jcmVhdGUuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
