"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _helpers = require("../helpers");

var _logger = _interopRequireWildcard(require("../logger"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const commands = {};

commands.getDevicesByParsing = async function getDevicesByParsing(platform) {
  const {
    stdout
  } = await this.exec('list', {
    args: ['devices']
  });
  const deviceSectionRe = _lodash.default.isEmpty(platform) ? new RegExp(`\\-\\-\\s+(\\S+)\\s+(\\S+)\\s+\\-\\-(\\n\\s{4}.+)*`, 'mgi') : new RegExp(`\\-\\-\\s+${_lodash.default.escapeRegExp(platform)}\\s+(\\S+)\\s+\\-\\-(\\n\\s{4}.+)*`, 'mgi');
  const matches = [];
  let match;

  while (match = deviceSectionRe.exec(stdout)) {
    matches.push(match);
  }

  if (_lodash.default.isEmpty(matches)) {
    throw new Error('Could not find device section');
  }

  const lineRe = /([^\s].+) \((\w+-.+\w+)\) \((\w+\s?\w+)\)/;
  const devices = {};

  for (match of matches) {
    const sdk = platform ? match[1] : match[2];
    devices[sdk] = devices[sdk] || [];

    for (const line of match[0].split('\n').slice(1)) {
      if (line.includes('(unavailable, ')) {
        continue;
      }

      const lineMatch = lineRe.exec(line);

      if (!lineMatch) {
        throw new Error(`Could not match line: ${line}`);
      }

      devices[sdk].push({
        name: lineMatch[1],
        udid: lineMatch[2],
        state: lineMatch[3],
        sdk,
        platform: platform || match[1]
      });
    }
  }

  return devices;
};

commands.getDevices = async function getDevices(forSdk, platform) {
  let devices = {};

  try {
    const {
      stdout
    } = await this.exec('list', {
      args: ['devices', '-j']
    });
    const versionMatchRe = _lodash.default.isEmpty(platform) ? new RegExp(`^([^\\s-]+)[\\s-](\\S+)`, 'i') : new RegExp(`^${_lodash.default.escapeRegExp(platform)}[\\s-](\\S+)`, 'i');

    for (let [sdkName, entries] of _lodash.default.toPairs(JSON.parse(stdout).devices)) {
      sdkName = sdkName.replace(_helpers.SIM_RUNTIME_NAME, '');
      const versionMatch = versionMatchRe.exec(sdkName);

      if (!versionMatch) {
        continue;
      }

      const sdk = (platform ? versionMatch[1] : versionMatch[2]).replace('-', '.');
      devices[sdk] = devices[sdk] || [];
      devices[sdk].push(...entries.filter(el => _lodash.default.isUndefined(el.isAvailable) || el.isAvailable).map(el => {
        delete el.availability;
        return {
          sdk,
          ...el,
          platform: platform || versionMatch[1]
        };
      }));
    }
  } catch (err) {
    _logger.default.debug(_logger.LOG_PREFIX, `Unable to get JSON device list: ${err.stack}`);

    _logger.default.debug(_logger.LOG_PREFIX, 'Falling back to manual parsing');

    devices = await this.getDevicesByParsing(platform);
  }

  if (!forSdk) {
    return devices;
  }

  if (devices[forSdk]) {
    return devices[forSdk];
  }

  let errMsg = `'${forSdk}' does not exist in the list of simctl SDKs.`;

  const availableSDKs = _lodash.default.keys(devices);

  errMsg += availableSDKs.length ? ` Only the following Simulator SDK versions are available on your system: ${availableSDKs.join(', ')}` : ` No Simulator SDK versions are available on your system. Please install some via Xcode preferences.`;
  throw new Error(errMsg);
};

commands.getRuntimeForPlatformVersionViaJson = async function getRuntimeForPlatformVersionViaJson(platformVersion, platform = 'iOS') {
  const {
    stdout
  } = await this.exec('list', {
    args: ['runtimes', '--json']
  });

  for (const {
    version,
    identifier,
    name
  } of JSON.parse(stdout).runtimes) {
    if ((0, _helpers.normalizeVersion)(version) === (0, _helpers.normalizeVersion)(platformVersion) && name.toLowerCase().startsWith(platform.toLowerCase())) {
      return identifier;
    }
  }

  throw new Error(`Could not use --json flag to parse platform version`);
};

commands.getRuntimeForPlatformVersion = async function getRuntimeForPlatformVersion(platformVersion, platform = 'iOS') {
  try {
    const {
      stdout
    } = await this.exec('list', {
      args: ['runtimes']
    });
    const runtimeRe = new RegExp(`${_lodash.default.escapeRegExp(platform)}\\s+(\\d+\\.\\d+)\\s+\\((\\d+\\.\\d+\\.*\\d*)`, 'i');

    for (const line of stdout.split('\n')) {
      const match = runtimeRe.exec(line);

      if (match && match[1] === platformVersion) {
        return match[2];
      }
    }
  } catch (ign) {}

  return platformVersion;
};

commands.getDeviceTypes = async function getDeviceTypes() {
  const {
    stdout
  } = await this.exec('list', {
    args: ['devicetypes', '-j']
  });

  try {
    const deviceTypes = JSON.parse(stdout.trim());
    return deviceTypes.devicetypes.map(type => type.name);
  } catch (err) {
    throw new Error(`Unable to get list of device types: ${err.message}`);
  }
};

commands.list = async function list() {
  const {
    stdout
  } = await this.exec('list', {
    args: ['-j']
  });

  try {
    return JSON.parse(stdout.trim());
  } catch (e) {
    throw new Error(`Unable to parse simctl list: ${e.message}`);
  }
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zdWJjb21tYW5kcy9saXN0LmpzIl0sIm5hbWVzIjpbImNvbW1hbmRzIiwiZ2V0RGV2aWNlc0J5UGFyc2luZyIsInBsYXRmb3JtIiwic3Rkb3V0IiwiZXhlYyIsImFyZ3MiLCJkZXZpY2VTZWN0aW9uUmUiLCJfIiwiaXNFbXB0eSIsIlJlZ0V4cCIsImVzY2FwZVJlZ0V4cCIsIm1hdGNoZXMiLCJtYXRjaCIsInB1c2giLCJFcnJvciIsImxpbmVSZSIsImRldmljZXMiLCJzZGsiLCJsaW5lIiwic3BsaXQiLCJzbGljZSIsImluY2x1ZGVzIiwibGluZU1hdGNoIiwibmFtZSIsInVkaWQiLCJzdGF0ZSIsImdldERldmljZXMiLCJmb3JTZGsiLCJ2ZXJzaW9uTWF0Y2hSZSIsInNka05hbWUiLCJlbnRyaWVzIiwidG9QYWlycyIsIkpTT04iLCJwYXJzZSIsInJlcGxhY2UiLCJTSU1fUlVOVElNRV9OQU1FIiwidmVyc2lvbk1hdGNoIiwiZmlsdGVyIiwiZWwiLCJpc1VuZGVmaW5lZCIsImlzQXZhaWxhYmxlIiwibWFwIiwiYXZhaWxhYmlsaXR5IiwiZXJyIiwibG9nIiwiZGVidWciLCJMT0dfUFJFRklYIiwic3RhY2siLCJlcnJNc2ciLCJhdmFpbGFibGVTREtzIiwia2V5cyIsImxlbmd0aCIsImpvaW4iLCJnZXRSdW50aW1lRm9yUGxhdGZvcm1WZXJzaW9uVmlhSnNvbiIsInBsYXRmb3JtVmVyc2lvbiIsInZlcnNpb24iLCJpZGVudGlmaWVyIiwicnVudGltZXMiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJnZXRSdW50aW1lRm9yUGxhdGZvcm1WZXJzaW9uIiwicnVudGltZVJlIiwiaWduIiwiZ2V0RGV2aWNlVHlwZXMiLCJkZXZpY2VUeXBlcyIsInRyaW0iLCJkZXZpY2V0eXBlcyIsInR5cGUiLCJtZXNzYWdlIiwibGlzdCIsImUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLE1BQU1BLFFBQVEsR0FBRyxFQUFqQjs7QUFxQkFBLFFBQVEsQ0FBQ0MsbUJBQVQsR0FBK0IsZUFBZUEsbUJBQWYsQ0FBb0NDLFFBQXBDLEVBQThDO0FBRTNFLFFBQU07QUFBQ0MsSUFBQUE7QUFBRCxNQUFXLE1BQU0sS0FBS0MsSUFBTCxDQUFVLE1BQVYsRUFBa0I7QUFDdkNDLElBQUFBLElBQUksRUFBRSxDQUFDLFNBQUQ7QUFEaUMsR0FBbEIsQ0FBdkI7QUFhQSxRQUFNQyxlQUFlLEdBQUdDLGdCQUFFQyxPQUFGLENBQVVOLFFBQVYsSUFDcEIsSUFBSU8sTUFBSixDQUFZLG9EQUFaLEVBQWlFLEtBQWpFLENBRG9CLEdBRXBCLElBQUlBLE1BQUosQ0FBWSxhQUFZRixnQkFBRUcsWUFBRixDQUFlUixRQUFmLENBQXlCLG9DQUFqRCxFQUFzRixLQUF0RixDQUZKO0FBR0EsUUFBTVMsT0FBTyxHQUFHLEVBQWhCO0FBQ0EsTUFBSUMsS0FBSjs7QUFFQSxTQUFRQSxLQUFLLEdBQUdOLGVBQWUsQ0FBQ0YsSUFBaEIsQ0FBcUJELE1BQXJCLENBQWhCLEVBQStDO0FBQzdDUSxJQUFBQSxPQUFPLENBQUNFLElBQVIsQ0FBYUQsS0FBYjtBQUNEOztBQUNELE1BQUlMLGdCQUFFQyxPQUFGLENBQVVHLE9BQVYsQ0FBSixFQUF3QjtBQUN0QixVQUFNLElBQUlHLEtBQUosQ0FBVSwrQkFBVixDQUFOO0FBQ0Q7O0FBRUQsUUFBTUMsTUFBTSxHQUFHLDJDQUFmO0FBRUEsUUFBTUMsT0FBTyxHQUFHLEVBQWhCOztBQUNBLE9BQUtKLEtBQUwsSUFBY0QsT0FBZCxFQUF1QjtBQUNyQixVQUFNTSxHQUFHLEdBQUdmLFFBQVEsR0FBR1UsS0FBSyxDQUFDLENBQUQsQ0FBUixHQUFjQSxLQUFLLENBQUMsQ0FBRCxDQUF2QztBQUNBSSxJQUFBQSxPQUFPLENBQUNDLEdBQUQsQ0FBUCxHQUFlRCxPQUFPLENBQUNDLEdBQUQsQ0FBUCxJQUFnQixFQUEvQjs7QUFFQSxTQUFLLE1BQU1DLElBQVgsSUFBbUJOLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU08sS0FBVCxDQUFlLElBQWYsRUFBcUJDLEtBQXJCLENBQTJCLENBQTNCLENBQW5CLEVBQWtEO0FBQ2hELFVBQUlGLElBQUksQ0FBQ0csUUFBTCxDQUFjLGdCQUFkLENBQUosRUFBcUM7QUFDbkM7QUFDRDs7QUFPRCxZQUFNQyxTQUFTLEdBQUdQLE1BQU0sQ0FBQ1gsSUFBUCxDQUFZYyxJQUFaLENBQWxCOztBQUNBLFVBQUksQ0FBQ0ksU0FBTCxFQUFnQjtBQUNkLGNBQU0sSUFBSVIsS0FBSixDQUFXLHlCQUF3QkksSUFBSyxFQUF4QyxDQUFOO0FBQ0Q7O0FBRURGLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBRCxDQUFQLENBQWFKLElBQWIsQ0FBa0I7QUFDaEJVLFFBQUFBLElBQUksRUFBRUQsU0FBUyxDQUFDLENBQUQsQ0FEQztBQUVoQkUsUUFBQUEsSUFBSSxFQUFFRixTQUFTLENBQUMsQ0FBRCxDQUZDO0FBR2hCRyxRQUFBQSxLQUFLLEVBQUVILFNBQVMsQ0FBQyxDQUFELENBSEE7QUFJaEJMLFFBQUFBLEdBSmdCO0FBS2hCZixRQUFBQSxRQUFRLEVBQUVBLFFBQVEsSUFBSVUsS0FBSyxDQUFDLENBQUQ7QUFMWCxPQUFsQjtBQU9EO0FBQ0Y7O0FBQ0QsU0FBT0ksT0FBUDtBQUNELENBNUREOztBQThFQWhCLFFBQVEsQ0FBQzBCLFVBQVQsR0FBc0IsZUFBZUEsVUFBZixDQUEyQkMsTUFBM0IsRUFBbUN6QixRQUFuQyxFQUE2QztBQUNqRSxNQUFJYyxPQUFPLEdBQUcsRUFBZDs7QUFDQSxNQUFJO0FBQ0YsVUFBTTtBQUFDYixNQUFBQTtBQUFELFFBQVcsTUFBTSxLQUFLQyxJQUFMLENBQVUsTUFBVixFQUFrQjtBQUN2Q0MsTUFBQUEsSUFBSSxFQUFFLENBQUMsU0FBRCxFQUFZLElBQVo7QUFEaUMsS0FBbEIsQ0FBdkI7QUFtQkEsVUFBTXVCLGNBQWMsR0FBR3JCLGdCQUFFQyxPQUFGLENBQVVOLFFBQVYsSUFDbkIsSUFBSU8sTUFBSixDQUFZLHlCQUFaLEVBQXNDLEdBQXRDLENBRG1CLEdBRW5CLElBQUlBLE1BQUosQ0FBWSxJQUFHRixnQkFBRUcsWUFBRixDQUFlUixRQUFmLENBQXlCLGNBQXhDLEVBQXVELEdBQXZELENBRko7O0FBR0EsU0FBSyxJQUFJLENBQUMyQixPQUFELEVBQVVDLE9BQVYsQ0FBVCxJQUErQnZCLGdCQUFFd0IsT0FBRixDQUFVQyxJQUFJLENBQUNDLEtBQUwsQ0FBVzlCLE1BQVgsRUFBbUJhLE9BQTdCLENBQS9CLEVBQXNFO0FBRXBFYSxNQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ssT0FBUixDQUFnQkMseUJBQWhCLEVBQWtDLEVBQWxDLENBQVY7QUFDQSxZQUFNQyxZQUFZLEdBQUdSLGNBQWMsQ0FBQ3hCLElBQWYsQ0FBb0J5QixPQUFwQixDQUFyQjs7QUFDQSxVQUFJLENBQUNPLFlBQUwsRUFBbUI7QUFDakI7QUFDRDs7QUFHRCxZQUFNbkIsR0FBRyxHQUFHLENBQUNmLFFBQVEsR0FBR2tDLFlBQVksQ0FBQyxDQUFELENBQWYsR0FBcUJBLFlBQVksQ0FBQyxDQUFELENBQTFDLEVBQStDRixPQUEvQyxDQUF1RCxHQUF2RCxFQUE0RCxHQUE1RCxDQUFaO0FBQ0FsQixNQUFBQSxPQUFPLENBQUNDLEdBQUQsQ0FBUCxHQUFlRCxPQUFPLENBQUNDLEdBQUQsQ0FBUCxJQUFnQixFQUEvQjtBQUNBRCxNQUFBQSxPQUFPLENBQUNDLEdBQUQsQ0FBUCxDQUFhSixJQUFiLENBQWtCLEdBQUdpQixPQUFPLENBQUNPLE1BQVIsQ0FBZ0JDLEVBQUQsSUFBUS9CLGdCQUFFZ0MsV0FBRixDQUFjRCxFQUFFLENBQUNFLFdBQWpCLEtBQWlDRixFQUFFLENBQUNFLFdBQTNELEVBQ2xCQyxHQURrQixDQUNiSCxFQUFELElBQVE7QUFDWCxlQUFPQSxFQUFFLENBQUNJLFlBQVY7QUFDQSxlQUFPO0FBQ0x6QixVQUFBQSxHQURLO0FBRUwsYUFBR3FCLEVBRkU7QUFHTHBDLFVBQUFBLFFBQVEsRUFBRUEsUUFBUSxJQUFJa0MsWUFBWSxDQUFDLENBQUQ7QUFIN0IsU0FBUDtBQUtELE9BUmtCLENBQXJCO0FBVUQ7QUFDRixHQTdDRCxDQTZDRSxPQUFPTyxHQUFQLEVBQVk7QUFDWkMsb0JBQUlDLEtBQUosQ0FBVUMsa0JBQVYsRUFBdUIsbUNBQWtDSCxHQUFHLENBQUNJLEtBQU0sRUFBbkU7O0FBQ0FILG9CQUFJQyxLQUFKLENBQVVDLGtCQUFWLEVBQXNCLGdDQUF0Qjs7QUFDQTlCLElBQUFBLE9BQU8sR0FBRyxNQUFNLEtBQUtmLG1CQUFMLENBQXlCQyxRQUF6QixDQUFoQjtBQUNEOztBQUVELE1BQUksQ0FBQ3lCLE1BQUwsRUFBYTtBQUNYLFdBQU9YLE9BQVA7QUFDRDs7QUFFRCxNQUFJQSxPQUFPLENBQUNXLE1BQUQsQ0FBWCxFQUFxQjtBQUNuQixXQUFPWCxPQUFPLENBQUNXLE1BQUQsQ0FBZDtBQUNEOztBQUVELE1BQUlxQixNQUFNLEdBQUksSUFBR3JCLE1BQU8sOENBQXhCOztBQUNBLFFBQU1zQixhQUFhLEdBQUcxQyxnQkFBRTJDLElBQUYsQ0FBT2xDLE9BQVAsQ0FBdEI7O0FBQ0FnQyxFQUFBQSxNQUFNLElBQUlDLGFBQWEsQ0FBQ0UsTUFBZCxHQUNMLDRFQUEyRUYsYUFBYSxDQUFDRyxJQUFkLENBQW1CLElBQW5CLENBQXlCLEVBRC9GLEdBRUwscUdBRkw7QUFHQSxRQUFNLElBQUl0QyxLQUFKLENBQVVrQyxNQUFWLENBQU47QUFDRCxDQW5FRDs7QUE4RUFoRCxRQUFRLENBQUNxRCxtQ0FBVCxHQUErQyxlQUFlQSxtQ0FBZixDQUM3Q0MsZUFENkMsRUFDNUJwRCxRQUFRLEdBQUcsS0FEaUIsRUFDVjtBQUNuQyxRQUFNO0FBQUNDLElBQUFBO0FBQUQsTUFBVyxNQUFNLEtBQUtDLElBQUwsQ0FBVSxNQUFWLEVBQWtCO0FBQ3ZDQyxJQUFBQSxJQUFJLEVBQUUsQ0FBQyxVQUFELEVBQWEsUUFBYjtBQURpQyxHQUFsQixDQUF2Qjs7QUFHQSxPQUFLLE1BQU07QUFBQ2tELElBQUFBLE9BQUQ7QUFBVUMsSUFBQUEsVUFBVjtBQUFzQmpDLElBQUFBO0FBQXRCLEdBQVgsSUFBMENTLElBQUksQ0FBQ0MsS0FBTCxDQUFXOUIsTUFBWCxFQUFtQnNELFFBQTdELEVBQXVFO0FBQ3JFLFFBQUksK0JBQWlCRixPQUFqQixNQUE4QiwrQkFBaUJELGVBQWpCLENBQTlCLElBQ0MvQixJQUFJLENBQUNtQyxXQUFMLEdBQW1CQyxVQUFuQixDQUE4QnpELFFBQVEsQ0FBQ3dELFdBQVQsRUFBOUIsQ0FETCxFQUM0RDtBQUMxRCxhQUFPRixVQUFQO0FBQ0Q7QUFDRjs7QUFDRCxRQUFNLElBQUkxQyxLQUFKLENBQVcscURBQVgsQ0FBTjtBQUNELENBWkQ7O0FBdUJBZCxRQUFRLENBQUM0RCw0QkFBVCxHQUF3QyxlQUFlQSw0QkFBZixDQUN0Q04sZUFEc0MsRUFDckJwRCxRQUFRLEdBQUcsS0FEVSxFQUNIO0FBRW5DLE1BQUk7QUFDRixVQUFNO0FBQUNDLE1BQUFBO0FBQUQsUUFBVyxNQUFNLEtBQUtDLElBQUwsQ0FBVSxNQUFWLEVBQWtCO0FBQ3ZDQyxNQUFBQSxJQUFJLEVBQUUsQ0FBQyxVQUFEO0FBRGlDLEtBQWxCLENBQXZCO0FBSUEsVUFBTXdELFNBQVMsR0FDYixJQUFJcEQsTUFBSixDQUFZLEdBQUVGLGdCQUFFRyxZQUFGLENBQWVSLFFBQWYsQ0FBeUIsK0NBQXZDLEVBQXVGLEdBQXZGLENBREY7O0FBRUEsU0FBSyxNQUFNZ0IsSUFBWCxJQUFtQmYsTUFBTSxDQUFDZ0IsS0FBUCxDQUFhLElBQWIsQ0FBbkIsRUFBdUM7QUFDckMsWUFBTVAsS0FBSyxHQUFHaUQsU0FBUyxDQUFDekQsSUFBVixDQUFlYyxJQUFmLENBQWQ7O0FBQ0EsVUFBSU4sS0FBSyxJQUFJQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEwQyxlQUExQixFQUEyQztBQUN6QyxlQUFPMUMsS0FBSyxDQUFDLENBQUQsQ0FBWjtBQUNEO0FBQ0Y7QUFDRixHQWJELENBYUUsT0FBT2tELEdBQVAsRUFBWSxDQUFFOztBQUdoQixTQUFPUixlQUFQO0FBQ0QsQ0FwQkQ7O0FBNEJBdEQsUUFBUSxDQUFDK0QsY0FBVCxHQUEwQixlQUFlQSxjQUFmLEdBQWlDO0FBQ3pELFFBQU07QUFBQzVELElBQUFBO0FBQUQsTUFBVyxNQUFNLEtBQUtDLElBQUwsQ0FBVSxNQUFWLEVBQWtCO0FBQ3ZDQyxJQUFBQSxJQUFJLEVBQUUsQ0FBQyxhQUFELEVBQWdCLElBQWhCO0FBRGlDLEdBQWxCLENBQXZCOztBQWNBLE1BQUk7QUFDRixVQUFNMkQsV0FBVyxHQUFHaEMsSUFBSSxDQUFDQyxLQUFMLENBQVc5QixNQUFNLENBQUM4RCxJQUFQLEVBQVgsQ0FBcEI7QUFDQSxXQUFPRCxXQUFXLENBQUNFLFdBQVosQ0FBd0J6QixHQUF4QixDQUE2QjBCLElBQUQsSUFBVUEsSUFBSSxDQUFDNUMsSUFBM0MsQ0FBUDtBQUNELEdBSEQsQ0FHRSxPQUFPb0IsR0FBUCxFQUFZO0FBQ1osVUFBTSxJQUFJN0IsS0FBSixDQUFXLHVDQUFzQzZCLEdBQUcsQ0FBQ3lCLE9BQVEsRUFBN0QsQ0FBTjtBQUNEO0FBQ0YsQ0FyQkQ7O0FBeURBcEUsUUFBUSxDQUFDcUUsSUFBVCxHQUFnQixlQUFlQSxJQUFmLEdBQXVCO0FBQ3JDLFFBQU07QUFBQ2xFLElBQUFBO0FBQUQsTUFBVyxNQUFNLEtBQUtDLElBQUwsQ0FBVSxNQUFWLEVBQWtCO0FBQ3ZDQyxJQUFBQSxJQUFJLEVBQUUsQ0FBQyxJQUFEO0FBRGlDLEdBQWxCLENBQXZCOztBQUdBLE1BQUk7QUFDRixXQUFPMkIsSUFBSSxDQUFDQyxLQUFMLENBQVc5QixNQUFNLENBQUM4RCxJQUFQLEVBQVgsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPSyxDQUFQLEVBQVU7QUFDVixVQUFNLElBQUl4RCxLQUFKLENBQVcsZ0NBQStCd0QsQ0FBQyxDQUFDRixPQUFRLEVBQXBELENBQU47QUFDRDtBQUNGLENBVEQ7O2VBV2VwRSxRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNJTV9SVU5USU1FX05BTUUsIG5vcm1hbGl6ZVZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBsb2csIHsgTE9HX1BSRUZJWCB9IGZyb20gJy4uL2xvZ2dlcic7XG5cblxuY29uc3QgY29tbWFuZHMgPSB7fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXZpY2VJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkZXZpY2UgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1ZGlkIC0gVGhlIGRldmljZSBVRElELlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gVGhlIGN1cnJlbnQgU2ltdWxhdG9yIHN0YXRlLCBmb3IgZXhhbXBsZSAnYm9vdGVkJyBvciAnc2h1dGRvd24nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNkayAtIFRoZSBTREsgdmVyc2lvbiwgZm9yIGV4YW1wbGUgJzEwLjMnLlxuICovXG5cbi8qKlxuICogUGFyc2UgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgU2ltdWxhdG9yIGRldmljZXMgdG8gcmVwcmVzZW50XG4gKiBpdCBhcyBjb252ZW5pZW50IG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBwbGF0Zm9ybSAtIFRoZSBwbGF0Zm9ybSBuYW1lLCBmb3IgZXhhbXBsZSAnd2F0Y2hPUycuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgbWFwcGluZy4gRWFjaCBrZXkgaXMgcGxhdGZvcm0gdmVyc2lvbixcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUgJzEwLjMnIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBpcyBhblxuICogICAgICAgICAgICAgICAgICBhcnJheSBvZiB0aGUgbWF0Y2hpbmcge0BsaW5rIERldmljZUluZm99IGluc3RhbmNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuY29tbWFuZHMuZ2V0RGV2aWNlc0J5UGFyc2luZyA9IGFzeW5jIGZ1bmN0aW9uIGdldERldmljZXNCeVBhcnNpbmcgKHBsYXRmb3JtKSB7XG4gIC8vIGdldCB0aGUgbGlzdCBvZiBkZXZpY2VzXG4gIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgdGhpcy5leGVjKCdsaXN0Jywge1xuICAgIGFyZ3M6IFsnZGV2aWNlcyddLFxuICB9KTtcblxuICAvLyBleHBlY3QgdG8gZ2V0IGEgbGlzdGluZyBsaWtlXG4gIC8vIC0tIGlPUyA4LjEgLS1cbiAgLy8gICAgIGlQaG9uZSA0cyAoM0NBNkU3REQtMjIwRS00NUU1LUI3MTYtMUU5OTJCM0E0MjlDKSAoU2h1dGRvd24pXG4gIC8vICAgICAuLi5cbiAgLy8gLS0gaU9TIDguMiAtLVxuICAvLyAgICAgaVBob25lIDRzIChBOTlGRkZDMy04RTE5LTREQ0YtQjU4NS03RDlENDZCNEMxNkUpIChTaHV0ZG93bilcbiAgLy8gICAgIC4uLlxuICAvLyBzbywgZ2V0IHRoZSBgLS0gaU9TIFguWCAtLWAgbGluZSB0byBmaW5kIHRoZSBzZGsgKFguWClcbiAgLy8gYW5kIHRoZSByZXN0IG9mIHRoZSBsaXN0aW5nIGluIG9yZGVyIHRvIGxhdGVyIGZpbmQgdGhlIGRldmljZXNcbiAgY29uc3QgZGV2aWNlU2VjdGlvblJlID0gXy5pc0VtcHR5KHBsYXRmb3JtKVxuICAgID8gbmV3IFJlZ0V4cChgXFxcXC1cXFxcLVxcXFxzKyhcXFxcUyspXFxcXHMrKFxcXFxTKylcXFxccytcXFxcLVxcXFwtKFxcXFxuXFxcXHN7NH0uKykqYCwgJ21naScpXG4gICAgOiBuZXcgUmVnRXhwKGBcXFxcLVxcXFwtXFxcXHMrJHtfLmVzY2FwZVJlZ0V4cChwbGF0Zm9ybSl9XFxcXHMrKFxcXFxTKylcXFxccytcXFxcLVxcXFwtKFxcXFxuXFxcXHN7NH0uKykqYCwgJ21naScpO1xuICBjb25zdCBtYXRjaGVzID0gW107XG4gIGxldCBtYXRjaDtcbiAgLy8gbWFrZSBhbiBlbnRyeSBmb3IgZWFjaCBzZGsgdmVyc2lvblxuICB3aGlsZSAoKG1hdGNoID0gZGV2aWNlU2VjdGlvblJlLmV4ZWMoc3Rkb3V0KSkpIHtcbiAgICBtYXRjaGVzLnB1c2gobWF0Y2gpO1xuICB9XG4gIGlmIChfLmlzRW1wdHkobWF0Y2hlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGRldmljZSBzZWN0aW9uJyk7XG4gIH1cblxuICBjb25zdCBsaW5lUmUgPSAvKFteXFxzXS4rKSBcXCgoXFx3Ky0uK1xcdyspXFwpIFxcKChcXHcrXFxzP1xcdyspXFwpLzsgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9sRzdtSzYvM1xuICAvLyBnZXQgYWxsIHRoZSBkZXZpY2VzIGZvciBlYWNoIHNka1xuICBjb25zdCBkZXZpY2VzID0ge307XG4gIGZvciAobWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGNvbnN0IHNkayA9IHBsYXRmb3JtID8gbWF0Y2hbMV0gOiBtYXRjaFsyXTtcbiAgICBkZXZpY2VzW3Nka10gPSBkZXZpY2VzW3Nka10gfHwgW107XG4gICAgLy8gc3BsaXQgdGhlIGZ1bGwgbWF0Y2ggaW50byBsaW5lcyBhbmQgcmVtb3ZlIHRoZSBmaXJzdFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBtYXRjaFswXS5zcGxpdCgnXFxuJykuc2xpY2UoMSkpIHtcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCcodW5hdmFpbGFibGUsICcpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gYSBsaW5lIGlzIHNvbWV0aGluZyBsaWtlXG4gICAgICAvLyAgICBpUGhvbmUgNHMgKEE5OUZGRkMzLThFMTktNERDRi1CNTg1LTdEOUQ0NkI0QzE2RSkgKFNodXRkb3duKVxuICAgICAgLy8gcmV0cmlldmU6XG4gICAgICAvLyAgIGlQaG9uZSA0c1xuICAgICAgLy8gICBBOTlGRkZDMy04RTE5LTREQ0YtQjU4NS03RDlENDZCNEMxNkVcbiAgICAgIC8vICAgU2h1dGRvd25cbiAgICAgIGNvbnN0IGxpbmVNYXRjaCA9IGxpbmVSZS5leGVjKGxpbmUpO1xuICAgICAgaWYgKCFsaW5lTWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbWF0Y2ggbGluZTogJHtsaW5lfWApO1xuICAgICAgfVxuICAgICAgLy8gc2F2ZSB0aGUgd2hvbGUgdGhpbmcgYXMgYWIgb2JqZWN0IGluIHRoZSBsaXN0IGZvciB0aGlzIHNka1xuICAgICAgZGV2aWNlc1tzZGtdLnB1c2goe1xuICAgICAgICBuYW1lOiBsaW5lTWF0Y2hbMV0sXG4gICAgICAgIHVkaWQ6IGxpbmVNYXRjaFsyXSxcbiAgICAgICAgc3RhdGU6IGxpbmVNYXRjaFszXSxcbiAgICAgICAgc2RrLFxuICAgICAgICBwbGF0Zm9ybTogcGxhdGZvcm0gfHwgbWF0Y2hbMV0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRldmljZXM7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIFNpbXVsYXRvciBkZXZpY2VzIHRvIHJlcHJlc2VudFxuICogaXQgYXMgY29udmVuaWVudCBtYXBwaW5nIGZvciB0aGUgcGFydGljdWxhciBwbGF0Zm9ybSB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gZm9yU2RrIC0gVGhlIHNkayB2ZXJzaW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igd2hpY2ggdGhlIGRldmljZXMgbGlzdCBzaG91bGQgYmUgcGFyc2VkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnMTAuMycuXG4gKiBAcGFyYW0gez9zdHJpbmd9IHBsYXRmb3JtIC0gVGhlIHBsYXRmb3JtIG5hbWUsIGZvciBleGFtcGxlICd3YXRjaE9TJy5cbiAqIEByZXR1cm4ge09iamVjdHxBcnJheTxEZXZpY2VJbmZvPn0gSWYgX2ZvclNka18gaXMgc2V0IHRoZW4gdGhlIGxpc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZGV2aWNlcyBmb3IgdGhlIHBhcnRpY3VsYXIgcGxhdGZvcm0gdmVyc2lvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlIHRoZSBzYW1lIHJlc3VsdCBhcyBmb3Ige0BsaW5rIGdldERldmljZXNCeVBhcnNpbmd9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBzdWJjb21tYW5kIGNvbW1hbmRcbiAqICAgICAgICAgICAgICAgICByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlIG9yIGlmIG5vIG1hdGNoaW5nXG4gKiAgICAgICAgICAgICAgICAgcGxhdGZvcm0gdmVyc2lvbiBpcyBmb3VuZCBpbiB0aGUgc3lzdGVtLlxuICovXG5jb21tYW5kcy5nZXREZXZpY2VzID0gYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlcyAoZm9yU2RrLCBwbGF0Zm9ybSkge1xuICBsZXQgZGV2aWNlcyA9IHt9O1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgdGhpcy5leGVjKCdsaXN0Jywge1xuICAgICAgYXJnczogWydkZXZpY2VzJywgJy1qJ10sXG4gICAgfSk7XG4gICAgLyogSlNPTiBzaG91bGQgYmVcbiAgICAgKiB7XG4gICAgICogICBcImRldmljZXNcIiA6IHtcbiAgICAgKiAgICAgXCJpT1MgPHNkaz5cIiA6IFsgLy8gb3JcbiAgICAgKiAgICAgXCJjb20uYXBwbGUuQ29yZVNpbXVsYXRvci5TaW1SdW50aW1lLmlPUy08c2RrPiA6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICBcInN0YXRlXCIgOiBcIkJvb3RlZFwiLFxuICAgICAqICAgICAgICAgXCJhdmFpbGFiaWxpdHlcIiA6IFwiKGF2YWlsYWJsZSlcIixcbiAgICAgKiAgICAgICAgIFwiaXNBdmFpbGFibGVcIiA6IHRydWUsXG4gICAgICogICAgICAgICBcIm5hbWVcIiA6IFwiaVBob25lIDZcIixcbiAgICAgKiAgICAgICAgIFwidWRpZFwiIDogXCI3NUUzNDE0MC0xOEU4LTREMUEtOUY0NS1BQUM3MzVERjc1REZcIlxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBjb25zdCB2ZXJzaW9uTWF0Y2hSZSA9IF8uaXNFbXB0eShwbGF0Zm9ybSlcbiAgICAgID8gbmV3IFJlZ0V4cChgXihbXlxcXFxzLV0rKVtcXFxccy1dKFxcXFxTKylgLCAnaScpXG4gICAgICA6IG5ldyBSZWdFeHAoYF4ke18uZXNjYXBlUmVnRXhwKHBsYXRmb3JtKX1bXFxcXHMtXShcXFxcUyspYCwgJ2knKTtcbiAgICBmb3IgKGxldCBbc2RrTmFtZSwgZW50cmllc10gb2YgXy50b1BhaXJzKEpTT04ucGFyc2Uoc3Rkb3V0KS5kZXZpY2VzKSkge1xuICAgICAgLy8gdGhlcmUgY291bGQgYmUgYSBsb25nZXIgbmFtZSwgc28gcmVtb3ZlIGl0XG4gICAgICBzZGtOYW1lID0gc2RrTmFtZS5yZXBsYWNlKFNJTV9SVU5USU1FX05BTUUsICcnKTtcbiAgICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IHZlcnNpb25NYXRjaFJlLmV4ZWMoc2RrTmFtZSk7XG4gICAgICBpZiAoIXZlcnNpb25NYXRjaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIHNkayBjYW4gaGF2ZSBkYXNoZXMgKGAxMi0yYCkgb3IgZG90cyAoYDEyLjFgKVxuICAgICAgY29uc3Qgc2RrID0gKHBsYXRmb3JtID8gdmVyc2lvbk1hdGNoWzFdIDogdmVyc2lvbk1hdGNoWzJdKS5yZXBsYWNlKCctJywgJy4nKTtcbiAgICAgIGRldmljZXNbc2RrXSA9IGRldmljZXNbc2RrXSB8fCBbXTtcbiAgICAgIGRldmljZXNbc2RrXS5wdXNoKC4uLmVudHJpZXMuZmlsdGVyKChlbCkgPT4gXy5pc1VuZGVmaW5lZChlbC5pc0F2YWlsYWJsZSkgfHwgZWwuaXNBdmFpbGFibGUpXG4gICAgICAgIC5tYXAoKGVsKSA9PiB7XG4gICAgICAgICAgZGVsZXRlIGVsLmF2YWlsYWJpbGl0eTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2RrLFxuICAgICAgICAgICAgLi4uZWwsXG4gICAgICAgICAgICBwbGF0Zm9ybTogcGxhdGZvcm0gfHwgdmVyc2lvbk1hdGNoWzFdLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKExPR19QUkVGSVgsIGBVbmFibGUgdG8gZ2V0IEpTT04gZGV2aWNlIGxpc3Q6ICR7ZXJyLnN0YWNrfWApO1xuICAgIGxvZy5kZWJ1ZyhMT0dfUFJFRklYLCAnRmFsbGluZyBiYWNrIHRvIG1hbnVhbCBwYXJzaW5nJyk7XG4gICAgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlc0J5UGFyc2luZyhwbGF0Zm9ybSk7XG4gIH1cblxuICBpZiAoIWZvclNkaykge1xuICAgIHJldHVybiBkZXZpY2VzO1xuICB9XG4gIC8vIGlmIGEgYGZvclNka2Agd2FzIHBhc3NlZCBpbiwgcmV0dXJuIG9ubHkgdGhlIGNvcnJlc3BvbmRpbmcgbGlzdFxuICBpZiAoZGV2aWNlc1tmb3JTZGtdKSB7XG4gICAgcmV0dXJuIGRldmljZXNbZm9yU2RrXTtcbiAgfVxuXG4gIGxldCBlcnJNc2cgPSBgJyR7Zm9yU2RrfScgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2Ygc2ltY3RsIFNES3MuYDtcbiAgY29uc3QgYXZhaWxhYmxlU0RLcyA9IF8ua2V5cyhkZXZpY2VzKTtcbiAgZXJyTXNnICs9IGF2YWlsYWJsZVNES3MubGVuZ3RoXG4gICAgPyBgIE9ubHkgdGhlIGZvbGxvd2luZyBTaW11bGF0b3IgU0RLIHZlcnNpb25zIGFyZSBhdmFpbGFibGUgb24geW91ciBzeXN0ZW06ICR7YXZhaWxhYmxlU0RLcy5qb2luKCcsICcpfWBcbiAgICA6IGAgTm8gU2ltdWxhdG9yIFNESyB2ZXJzaW9ucyBhcmUgYXZhaWxhYmxlIG9uIHlvdXIgc3lzdGVtLiBQbGVhc2UgaW5zdGFsbCBzb21lIHZpYSBYY29kZSBwcmVmZXJlbmNlcy5gO1xuICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBydW50aW1lIGZvciB0aGUgcGFydGljdWxhciBwbGF0Zm9ybSB2ZXJzaW9uIHVzaW5nIC0tanNvbiBmbGFnXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtVmVyc2lvbiAtIFRoZSBwbGF0Zm9ybSB2ZXJzaW9uIG5hbWUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUgJzEwLjMnLlxuICogQHBhcmFtIHs/c3RyaW5nfSBwbGF0Zm9ybSAtIFRoZSBwbGF0Zm9ybSBuYW1lLCBmb3IgZXhhbXBsZSAnd2F0Y2hPUycuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb3JyZXNwb25kaW5nIHJ1bnRpbWUgbmFtZSBmb3IgdGhlIGdpdmVuXG4gKiAgICAgICAgICAgICAgICAgIHBsYXRmb3JtIHZlcnNpb24uXG4gKi9cbmNvbW1hbmRzLmdldFJ1bnRpbWVGb3JQbGF0Zm9ybVZlcnNpb25WaWFKc29uID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvblZpYUpzb24gKFxuICBwbGF0Zm9ybVZlcnNpb24sIHBsYXRmb3JtID0gJ2lPUycpIHtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWMoJ2xpc3QnLCB7XG4gICAgYXJnczogWydydW50aW1lcycsICctLWpzb24nXSxcbiAgfSk7XG4gIGZvciAoY29uc3Qge3ZlcnNpb24sIGlkZW50aWZpZXIsIG5hbWV9IG9mIEpTT04ucGFyc2Uoc3Rkb3V0KS5ydW50aW1lcykge1xuICAgIGlmIChub3JtYWxpemVWZXJzaW9uKHZlcnNpb24pID09PSBub3JtYWxpemVWZXJzaW9uKHBsYXRmb3JtVmVyc2lvbilcbiAgICAgICYmIG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHBsYXRmb3JtLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgdXNlIC0tanNvbiBmbGFnIHRvIHBhcnNlIHBsYXRmb3JtIHZlcnNpb25gKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBydW50aW1lIGZvciB0aGUgcGFydGljdWxhciBwbGF0Zm9ybSB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybVZlcnNpb24gLSBUaGUgcGxhdGZvcm0gdmVyc2lvbiBuYW1lLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlICcxMC4zJy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gcGxhdGZvcm0gLSBUaGUgcGxhdGZvcm0gbmFtZSwgZm9yIGV4YW1wbGUgJ3dhdGNoT1MnLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29ycmVzcG9uZGluZyBydW50aW1lIG5hbWUgZm9yIHRoZSBnaXZlblxuICogICAgICAgICAgICAgICAgICBwbGF0Zm9ybSB2ZXJzaW9uLlxuICovXG5jb21tYW5kcy5nZXRSdW50aW1lRm9yUGxhdGZvcm1WZXJzaW9uID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvbiAoXG4gIHBsYXRmb3JtVmVyc2lvbiwgcGxhdGZvcm0gPSAnaU9TJykge1xuICAvLyBUcnkgd2l0aCBwYXJzaW5nXG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWMoJ2xpc3QnLCB7XG4gICAgICBhcmdzOiBbJ3J1bnRpbWVzJ10sXG4gICAgfSk7XG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9VeWtqUVovMVxuICAgIGNvbnN0IHJ1bnRpbWVSZSA9XG4gICAgICBuZXcgUmVnRXhwKGAke18uZXNjYXBlUmVnRXhwKHBsYXRmb3JtKX1cXFxccysoXFxcXGQrXFxcXC5cXFxcZCspXFxcXHMrXFxcXCgoXFxcXGQrXFxcXC5cXFxcZCtcXFxcLipcXFxcZCopYCwgJ2knKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3Rkb3V0LnNwbGl0KCdcXG4nKSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBydW50aW1lUmUuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSA9PT0gcGxhdGZvcm1WZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGlnbikge31cblxuICAvLyBpZiBub3RoaW5nIHdhcyBmb3VuZCwgcGFzcyBwbGF0Zm9ybSB2ZXJzaW9uIGJhY2tcbiAgcmV0dXJuIHBsYXRmb3JtVmVyc2lvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGRldmljZSB0eXBlcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgWGNvZGUgaW5zdGFsbGF0aW9uXG4gKlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gTGlzdCBvZiB0aGUgdHlwZXMgb2YgZGV2aWNlcyBhdmFpbGFibGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgY29tbWFuZCBmYWlsc1xuICovXG5jb21tYW5kcy5nZXREZXZpY2VUeXBlcyA9IGFzeW5jIGZ1bmN0aW9uIGdldERldmljZVR5cGVzICgpIHtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWMoJ2xpc3QnLCB7XG4gICAgYXJnczogWydkZXZpY2V0eXBlcycsICctaiddLFxuICB9KTtcbiAgLypcbiAgICogSlNPTiB3aWxsIGJlIGxpa2U6XG4gICAqICAge1xuICAgKiAgICAgXCJkZXZpY2V0eXBlc1wiIDogW1xuICAgKiAgICAgICB7XG4gICAqICAgICAgICAgXCJuYW1lXCIgOiBcImlQaG9uZSA0c1wiLFxuICAgKiAgICAgICAgIFwiaWRlbnRpZmllclwiIDogXCJjb20uYXBwbGUuQ29yZVNpbXVsYXRvci5TaW1EZXZpY2VUeXBlLmlQaG9uZS00c1wiXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIC4uLlxuICAgKiAgIH1cbiAgICovXG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlVHlwZXMgPSBKU09OLnBhcnNlKHN0ZG91dC50cmltKCkpO1xuICAgIHJldHVybiBkZXZpY2VUeXBlcy5kZXZpY2V0eXBlcy5tYXAoKHR5cGUpID0+IHR5cGUubmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBsaXN0IG9mIGRldmljZSB0eXBlczogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZ1bGwgbGlzdCBvZiBydW50aW1lcywgZGV2aWNldHlwZXMsIGRldmljZXMgYW5kIHBhaXJzIGFzIE9iamVjdFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgZGV2aWNlIHR5cGVzLCBydW50aW1lcyBkZXZpY2VzIGFuZCBwYWlycy5cbiAqIFRoZSByZXN1bHRpbmcgSlNPTiB3aWxsIGJlIGxpa2U6XG4gKiAgIHtcbiAqICAgICBcImRldmljZXR5cGVzXCIgOiBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIFwibmFtZVwiIDogXCJpUGhvbmUgNHNcIixcbiAqICAgICAgICAgXCJpZGVudGlmaWVyXCIgOiBcImNvbS5hcHBsZS5Db3JlU2ltdWxhdG9yLlNpbURldmljZVR5cGUuaVBob25lLTRzXCJcbiAqICAgICAgIH0sXG4gKiAgICAgICAuLi5cbiAqICAgICAgXSxcbiAqICAgICBcInJ1bnRpbWVzXCIgOiBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIFwidmVyc2lvblwiIDogJzEzLjAnLFxuICogICAgICAgICBcImJ1bmRsZVBhdGhcIiA6ICcvQXBwbGljYXRpb25zL1hjb2RlMTFiZXRhNC5hcHAvQ29udGVudHMvRGV2ZWxvcGVyL1BsYXRmb3Jtcy9pUGhvbmVPUy5wbGF0Zm9ybS9MaWJyYXJ5L0RldmVsb3Blci9Db3JlU2ltdWxhdG9yL1Byb2ZpbGVzL1J1bnRpbWVzL2lPUy5zaW1ydW50aW1lJyxcbiAqICAgICAgICAgXCJpc0F2YWlsYWJsZVwiIDogdHJ1ZSxcbiAqICAgICAgICAgXCJuYW1lXCIgOiAnaU9TIDEzLjAnLFxuICogICAgICAgICBcImlkZW50aWZpZXJcIiA6ICdjb20uYXBwbGUuQ29yZVNpbXVsYXRvci5TaW1SdW50aW1lLmlPUy0xMy0wJyxcbiAqICAgICAgICAgXCJidWlsZHZlcnNpb25cIiA6ICcxN0E1NTM0ZCdcbiAqICAgICAgIH0sXG4gKiAgICAgICAuLi5cbiAqICAgICAgfSxcbiAqICAgICBcImRldmljZXNcIiA6XG4gKiAgICAgICB7XG4gKiAgICAgICAgICdjb20uYXBwbGUuQ29yZVNpbXVsYXRvci5TaW1SdW50aW1lLmlPUy0xMy0wJzogWyBbT2JqZWN0XSwgW09iamVjdF0gXSB9LFxuICogICAgICAgICAuLi5cbiAqICAgICAgIH0sXG4gKiAgICAgXCJwYWlyc1wiIDoge30gfVxuICpcbiAqICAgfVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb3JyZXNwb25kaW5nIHNpbWN0bCBjb21tYW5kIGZhaWxzXG4gKi9cbmNvbW1hbmRzLmxpc3QgPSBhc3luYyBmdW5jdGlvbiBsaXN0ICgpIHtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWMoJ2xpc3QnLCB7XG4gICAgYXJnczogWyctaiddLFxuICB9KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdGRvdXQudHJpbSgpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHNpbWN0bCBsaXN0OiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHM7XG4iXSwiZmlsZSI6ImxpYi9zdWJjb21tYW5kcy9saXN0LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
