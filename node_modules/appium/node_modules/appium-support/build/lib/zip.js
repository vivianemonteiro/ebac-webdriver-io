"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toInMemoryZip = toInMemoryZip;
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.toArchive = toArchive;
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _mkdirp = require("../lib/mkdirp");

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _system = require("./system");

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

var _getStream = _interopRequireDefault(require("get-stream"));

var _teen_process = require("teen_process");

const openZip = _bluebird.default.promisify(_yauzl.default.open);

const pipeline = _bluebird.default.promisify(_stream.default.pipeline);

const ZIP_MAGIC = 'PK';
const IFMT = 61440;
const IFDIR = 16384;
const IFLNK = 40960;

class ZipExtractor {
  constructor(sourcePath, opts = {}) {
    this.zipPath = sourcePath;
    this.opts = opts;
    this.canceled = false;
  }

  extractFileName(entry) {
    return _lodash.default.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;
  }

  async extract() {
    const {
      dir,
      fileNamesEncoding
    } = this.opts;
    this.zipfile = await openZip(this.zipPath, {
      lazyEntries: true,
      decodeStrings: !fileNamesEncoding
    });
    this.canceled = false;
    return new _bluebird.default((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true;
        reject(err);
      });
      this.zipfile.readEntry();
      this.zipfile.on('close', () => {
        if (!this.canceled) {
          resolve();
        }
      });
      this.zipfile.on('entry', async entry => {
        if (this.canceled) {
          return;
        }

        const fileName = this.extractFileName(entry);

        if (fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry();
          return;
        }

        const destDir = _path.default.dirname(_path.default.join(dir, fileName));

        try {
          await _fs2.default.mkdir(destDir, {
            recursive: true
          });
          const canonicalDestDir = await _fs2.default.realpath(destDir);

          const relativeDestDir = _path.default.relative(dir, canonicalDestDir);

          if (relativeDestDir.split(_path.default.sep).includes('..')) {
            new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${fileName}`);
          }

          await this.extractEntry(entry);
          this.zipfile.readEntry();
        } catch (err) {
          this.canceled = true;
          this.zipfile.close();
          reject(err);
        }
      });
    });
  }

  async extractEntry(entry) {
    if (this.canceled) {
      return;
    }

    const {
      dir
    } = this.opts;
    const fileName = this.extractFileName(entry);

    const dest = _path.default.join(dir, fileName);

    const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
    const isSymlink = (mode & IFMT) === IFLNK;
    const isDir = (mode & IFMT) === IFDIR || fileName.endsWith('/') || entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16;
    const procMode = this.getExtractedMode(mode, isDir) & 0o777;
    const destDir = isDir ? dest : _path.default.dirname(dest);
    const mkdirOptions = {
      recursive: true
    };

    if (isDir) {
      mkdirOptions.mode = procMode;
    }

    await _fs2.default.mkdir(destDir, mkdirOptions);

    if (isDir) {
      return;
    }

    const readStream = await _bluebird.default.promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);

    if (isSymlink) {
      const link = await (0, _getStream.default)(readStream);
      await _fs2.default.symlink(link, dest);
    } else {
      await pipeline(readStream, _fs2.default.createWriteStream(dest, {
        mode: procMode
      }));
    }
  }

  getExtractedMode(entryMode, isDir) {
    const {
      defaultDirMode,
      defaultFileMode
    } = this.opts;
    let mode = entryMode;

    if (mode === 0) {
      if (isDir) {
        if (defaultDirMode) {
          mode = parseInt(defaultDirMode, 10);
        }

        if (!mode) {
          mode = 0o755;
        }
      } else {
        if (defaultFileMode) {
          mode = parseInt(defaultFileMode, 10);
        }

        if (!mode) {
          mode = 0o644;
        }
      }
    }

    return mode;
  }

}

async function extractAllTo(zipFilePath, destDir, opts = {}) {
  if (!_path.default.isAbsolute(destDir)) {
    throw new Error(`Target path '${destDir}' is expected to be absolute`);
  }

  await _fs2.default.mkdir(destDir, {
    recursive: true
  });
  const dir = await _fs2.default.realpath(destDir);

  if (opts.useSystemUnzip) {
    try {
      await extractWithSystemUnzip(zipFilePath, dir);
      return;
    } catch (err) {
      _logger.default.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);
    }
  }

  const extractor = new ZipExtractor(zipFilePath, { ...opts,
    dir
  });
  await extractor.extract();
}

async function extractWithSystemUnzip(zipFilePath, destDir) {
  const isWindowsHost = (0, _system.isWindows)();
  let executablePath;

  try {
    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');
  } catch (e) {
    throw new Error('Could not find system unzip');
  }

  if (isWindowsHost) {
    await (0, _teen_process.exec)(executablePath, ['-command', 'Expand-Archive', '-LiteralPath', zipFilePath, '-DestinationPath', destDir, '-Force']);
  } else {
    await (0, _teen_process.exec)(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);
  }
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await (0, _mkdirp.mkdirp)(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await (0, _mkdirp.mkdirp)(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await openZip(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('finish', resolve);
    archive.finalize();
  });
}

const getExecutablePath = _lodash.default.memoize(async function getExecutablePath(binaryName) {
  const fullPath = await _fs2.default.which(binaryName);

  _logger.default.debug(`Found '%s' at '%s'`, binaryName, fullPath);

  return fullPath;
});

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi96aXAuanMiXSwibmFtZXMiOlsib3BlblppcCIsIkIiLCJwcm9taXNpZnkiLCJ5YXV6bCIsIm9wZW4iLCJwaXBlbGluZSIsInN0cmVhbSIsIlpJUF9NQUdJQyIsIklGTVQiLCJJRkRJUiIsIklGTE5LIiwiWmlwRXh0cmFjdG9yIiwiY29uc3RydWN0b3IiLCJzb3VyY2VQYXRoIiwib3B0cyIsInppcFBhdGgiLCJjYW5jZWxlZCIsImV4dHJhY3RGaWxlTmFtZSIsImVudHJ5IiwiXyIsImlzQnVmZmVyIiwiZmlsZU5hbWUiLCJ0b1N0cmluZyIsImZpbGVOYW1lc0VuY29kaW5nIiwiZXh0cmFjdCIsImRpciIsInppcGZpbGUiLCJsYXp5RW50cmllcyIsImRlY29kZVN0cmluZ3MiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJlcnIiLCJyZWFkRW50cnkiLCJzdGFydHNXaXRoIiwiZGVzdERpciIsInBhdGgiLCJkaXJuYW1lIiwiam9pbiIsImZzIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJjYW5vbmljYWxEZXN0RGlyIiwicmVhbHBhdGgiLCJyZWxhdGl2ZURlc3REaXIiLCJyZWxhdGl2ZSIsInNwbGl0Iiwic2VwIiwiaW5jbHVkZXMiLCJFcnJvciIsImV4dHJhY3RFbnRyeSIsImNsb3NlIiwiZGVzdCIsIm1vZGUiLCJleHRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwiaXNTeW1saW5rIiwiaXNEaXIiLCJlbmRzV2l0aCIsInZlcnNpb25NYWRlQnkiLCJwcm9jTW9kZSIsImdldEV4dHJhY3RlZE1vZGUiLCJta2Rpck9wdGlvbnMiLCJyZWFkU3RyZWFtIiwib3BlblJlYWRTdHJlYW0iLCJiaW5kIiwibGluayIsInN5bWxpbmsiLCJjcmVhdGVXcml0ZVN0cmVhbSIsImVudHJ5TW9kZSIsImRlZmF1bHREaXJNb2RlIiwiZGVmYXVsdEZpbGVNb2RlIiwicGFyc2VJbnQiLCJleHRyYWN0QWxsVG8iLCJ6aXBGaWxlUGF0aCIsImlzQWJzb2x1dGUiLCJ1c2VTeXN0ZW1VbnppcCIsImV4dHJhY3RXaXRoU3lzdGVtVW56aXAiLCJsb2ciLCJ3YXJuIiwic3RkZXJyIiwibWVzc2FnZSIsImV4dHJhY3RvciIsImlzV2luZG93c0hvc3QiLCJleGVjdXRhYmxlUGF0aCIsImdldEV4ZWN1dGFibGVQYXRoIiwiZSIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJkc3RQYXRoIiwidGVzdCIsImV4aXN0cyIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInJlcyIsImV4dHJhY3RFbnRyeVRvIiwiZW1pdCIsInRvSW5NZW1vcnlaaXAiLCJzcmNQYXRoIiwiaXNNZXRlcmVkIiwiZW5jb2RlVG9CYXNlNjQiLCJtYXhTaXplIiwiR2lCIiwibGV2ZWwiLCJyZXN1bHRCdWZmZXJzIiwicmVzdWx0QnVmZmVyc1NpemUiLCJyZXN1bHRXcml0ZVN0cmVhbSIsIldyaXRhYmxlIiwid3JpdGUiLCJidWZmZXIiLCJlbmNvZGluZyIsIm5leHQiLCJwdXNoIiwibGVuZ3RoIiwiYXJjaGl2ZSIsInpsaWIiLCJzcmNTaXplIiwiYmFzZTY0RW5jb2RlclN0cmVhbSIsIkJhc2U2NEVuY29kZSIsInJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZSIsInVucGlwZSIsImFib3J0IiwiZGVzdHJveSIsInBvaW50ZXIiLCJhcmNoaXZlU3RyZWFtUHJvbWlzZSIsInRpbWVyIiwiVGltZXIiLCJzdGFydCIsInN0YXQiLCJpc0RpcmVjdG9yeSIsImRpcmVjdG9yeSIsImZpbGUiLCJuYW1lIiwiYmFzZW5hbWUiLCJmaW5hbGl6ZSIsImRlYnVnIiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiQnVmZmVyIiwiY29uY2F0IiwiYXNzZXJ0VmFsaWRaaXAiLCJmaWxlUGF0aCIsInNpemUiLCJmZCIsImFsbG9jIiwicmVhZCIsInNpZ25hdHVyZSIsInRvQXJjaGl2ZSIsInNyYyIsInBhdHRlcm4iLCJjd2QiLCJpZ25vcmUiLCJnbG9iIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJmdWxsUGF0aCIsIndoaWNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLE9BQU8sR0FBR0Msa0JBQUVDLFNBQUYsQ0FBWUMsZUFBTUMsSUFBbEIsQ0FBaEI7O0FBQ0EsTUFBTUMsUUFBUSxHQUFHSixrQkFBRUMsU0FBRixDQUFZSSxnQkFBT0QsUUFBbkIsQ0FBakI7O0FBQ0EsTUFBTUUsU0FBUyxHQUFHLElBQWxCO0FBQ0EsTUFBTUMsSUFBSSxHQUFHLEtBQWI7QUFDQSxNQUFNQyxLQUFLLEdBQUcsS0FBZDtBQUNBLE1BQU1DLEtBQUssR0FBRyxLQUFkOztBQUdBLE1BQU1DLFlBQU4sQ0FBbUI7QUFDakJDLEVBQUFBLFdBQVcsQ0FBRUMsVUFBRixFQUFjQyxJQUFJLEdBQUcsRUFBckIsRUFBeUI7QUFDbEMsU0FBS0MsT0FBTCxHQUFlRixVQUFmO0FBQ0EsU0FBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0UsUUFBTCxHQUFnQixLQUFoQjtBQUNEOztBQUVEQyxFQUFBQSxlQUFlLENBQUVDLEtBQUYsRUFBUztBQUN0QixXQUFPQyxnQkFBRUMsUUFBRixDQUFXRixLQUFLLENBQUNHLFFBQWpCLElBQTZCSCxLQUFLLENBQUNHLFFBQU4sQ0FBZUMsUUFBZixDQUF3QixLQUFLUixJQUFMLENBQVVTLGlCQUFsQyxDQUE3QixHQUFvRkwsS0FBSyxDQUFDRyxRQUFqRztBQUNEOztBQUVELFFBQU1HLE9BQU4sR0FBaUI7QUFDZixVQUFNO0FBQ0pDLE1BQUFBLEdBREk7QUFFSkYsTUFBQUE7QUFGSSxRQUdGLEtBQUtULElBSFQ7QUFJQSxTQUFLWSxPQUFMLEdBQWUsTUFBTTFCLE9BQU8sQ0FBQyxLQUFLZSxPQUFOLEVBQWU7QUFDekNZLE1BQUFBLFdBQVcsRUFBRSxJQUQ0QjtBQUd6Q0MsTUFBQUEsYUFBYSxFQUFFLENBQUNMO0FBSHlCLEtBQWYsQ0FBNUI7QUFLQSxTQUFLUCxRQUFMLEdBQWdCLEtBQWhCO0FBRUEsV0FBTyxJQUFJZixpQkFBSixDQUFNLENBQUM0QixPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDaEMsV0FBS0osT0FBTCxDQUFhSyxFQUFiLENBQWdCLE9BQWhCLEVBQTBCQyxHQUFELElBQVM7QUFDaEMsYUFBS2hCLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQWMsUUFBQUEsTUFBTSxDQUFDRSxHQUFELENBQU47QUFDRCxPQUhEO0FBSUEsV0FBS04sT0FBTCxDQUFhTyxTQUFiO0FBRUEsV0FBS1AsT0FBTCxDQUFhSyxFQUFiLENBQWdCLE9BQWhCLEVBQXlCLE1BQU07QUFDN0IsWUFBSSxDQUFDLEtBQUtmLFFBQVYsRUFBb0I7QUFDbEJhLFVBQUFBLE9BQU87QUFDUjtBQUNGLE9BSkQ7QUFNQSxXQUFLSCxPQUFMLENBQWFLLEVBQWIsQ0FBZ0IsT0FBaEIsRUFBeUIsTUFBT2IsS0FBUCxJQUFpQjtBQUN4QyxZQUFJLEtBQUtGLFFBQVQsRUFBbUI7QUFDakI7QUFDRDs7QUFFRCxjQUFNSyxRQUFRLEdBQUcsS0FBS0osZUFBTCxDQUFxQkMsS0FBckIsQ0FBakI7O0FBQ0EsWUFBSUcsUUFBUSxDQUFDYSxVQUFULENBQW9CLFdBQXBCLENBQUosRUFBc0M7QUFDcEMsZUFBS1IsT0FBTCxDQUFhTyxTQUFiO0FBQ0E7QUFDRDs7QUFFRCxjQUFNRSxPQUFPLEdBQUdDLGNBQUtDLE9BQUwsQ0FBYUQsY0FBS0UsSUFBTCxDQUFVYixHQUFWLEVBQWVKLFFBQWYsQ0FBYixDQUFoQjs7QUFDQSxZQUFJO0FBQ0YsZ0JBQU1rQixhQUFHQyxLQUFILENBQVNMLE9BQVQsRUFBa0I7QUFBQ00sWUFBQUEsU0FBUyxFQUFFO0FBQVosV0FBbEIsQ0FBTjtBQUVBLGdCQUFNQyxnQkFBZ0IsR0FBRyxNQUFNSCxhQUFHSSxRQUFILENBQVlSLE9BQVosQ0FBL0I7O0FBQ0EsZ0JBQU1TLGVBQWUsR0FBR1IsY0FBS1MsUUFBTCxDQUFjcEIsR0FBZCxFQUFtQmlCLGdCQUFuQixDQUF4Qjs7QUFFQSxjQUFJRSxlQUFlLENBQUNFLEtBQWhCLENBQXNCVixjQUFLVyxHQUEzQixFQUFnQ0MsUUFBaEMsQ0FBeUMsSUFBekMsQ0FBSixFQUFvRDtBQUNsRCxnQkFBSUMsS0FBSixDQUFXLHNCQUFxQlAsZ0JBQWlCLGlDQUFnQ3JCLFFBQVMsRUFBMUY7QUFDRDs7QUFFRCxnQkFBTSxLQUFLNkIsWUFBTCxDQUFrQmhDLEtBQWxCLENBQU47QUFDQSxlQUFLUSxPQUFMLENBQWFPLFNBQWI7QUFDRCxTQVpELENBWUUsT0FBT0QsR0FBUCxFQUFZO0FBQ1osZUFBS2hCLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxlQUFLVSxPQUFMLENBQWF5QixLQUFiO0FBQ0FyQixVQUFBQSxNQUFNLENBQUNFLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsT0E3QkQ7QUE4QkQsS0EzQ00sQ0FBUDtBQTRDRDs7QUFFRCxRQUFNa0IsWUFBTixDQUFvQmhDLEtBQXBCLEVBQTJCO0FBQ3pCLFFBQUksS0FBS0YsUUFBVCxFQUFtQjtBQUNqQjtBQUNEOztBQUVELFVBQU07QUFDSlMsTUFBQUE7QUFESSxRQUVGLEtBQUtYLElBRlQ7QUFJQSxVQUFNTyxRQUFRLEdBQUcsS0FBS0osZUFBTCxDQUFxQkMsS0FBckIsQ0FBakI7O0FBQ0EsVUFBTWtDLElBQUksR0FBR2hCLGNBQUtFLElBQUwsQ0FBVWIsR0FBVixFQUFlSixRQUFmLENBQWI7O0FBR0EsVUFBTWdDLElBQUksR0FBSW5DLEtBQUssQ0FBQ29DLHNCQUFOLElBQWdDLEVBQWpDLEdBQXVDLE1BQXBEO0FBRUEsVUFBTUMsU0FBUyxHQUFHLENBQUNGLElBQUksR0FBRzdDLElBQVIsTUFBa0JFLEtBQXBDO0FBQ0EsVUFBTThDLEtBQUssR0FBRyxDQUFDSCxJQUFJLEdBQUc3QyxJQUFSLE1BQWtCQyxLQUFsQixJQUVUWSxRQUFRLENBQUNvQyxRQUFULENBQWtCLEdBQWxCLENBRlMsSUFLUnZDLEtBQUssQ0FBQ3dDLGFBQU4sSUFBdUIsQ0FBdkIsS0FBNkIsQ0FBN0IsSUFBa0N4QyxLQUFLLENBQUNvQyxzQkFBTixLQUFpQyxFQUx6RTtBQU1BLFVBQU1LLFFBQVEsR0FBRyxLQUFLQyxnQkFBTCxDQUFzQlAsSUFBdEIsRUFBNEJHLEtBQTVCLElBQXFDLEtBQXREO0FBRUEsVUFBTXJCLE9BQU8sR0FBR3FCLEtBQUssR0FBR0osSUFBSCxHQUFVaEIsY0FBS0MsT0FBTCxDQUFhZSxJQUFiLENBQS9CO0FBQ0EsVUFBTVMsWUFBWSxHQUFHO0FBQUVwQixNQUFBQSxTQUFTLEVBQUU7QUFBYixLQUFyQjs7QUFDQSxRQUFJZSxLQUFKLEVBQVc7QUFDVEssTUFBQUEsWUFBWSxDQUFDUixJQUFiLEdBQW9CTSxRQUFwQjtBQUNEOztBQUNELFVBQU1wQixhQUFHQyxLQUFILENBQVNMLE9BQVQsRUFBa0IwQixZQUFsQixDQUFOOztBQUNBLFFBQUlMLEtBQUosRUFBVztBQUNUO0FBQ0Q7O0FBRUQsVUFBTU0sVUFBVSxHQUFHLE1BQU03RCxrQkFBRUMsU0FBRixDQUFZLEtBQUt3QixPQUFMLENBQWFxQyxjQUFiLENBQTRCQyxJQUE1QixDQUFpQyxLQUFLdEMsT0FBdEMsQ0FBWixFQUE0RFIsS0FBNUQsQ0FBekI7O0FBQ0EsUUFBSXFDLFNBQUosRUFBZTtBQUNiLFlBQU1VLElBQUksR0FBRyxNQUFNLHdCQUFVSCxVQUFWLENBQW5CO0FBQ0EsWUFBTXZCLGFBQUcyQixPQUFILENBQVdELElBQVgsRUFBaUJiLElBQWpCLENBQU47QUFDRCxLQUhELE1BR087QUFDTCxZQUFNL0MsUUFBUSxDQUFDeUQsVUFBRCxFQUFhdkIsYUFBRzRCLGlCQUFILENBQXFCZixJQUFyQixFQUEyQjtBQUFFQyxRQUFBQSxJQUFJLEVBQUVNO0FBQVIsT0FBM0IsQ0FBYixDQUFkO0FBQ0Q7QUFDRjs7QUFFREMsRUFBQUEsZ0JBQWdCLENBQUVRLFNBQUYsRUFBYVosS0FBYixFQUFvQjtBQUNsQyxVQUFNO0FBQ0phLE1BQUFBLGNBREk7QUFFSkMsTUFBQUE7QUFGSSxRQUdGLEtBQUt4RCxJQUhUO0FBS0EsUUFBSXVDLElBQUksR0FBR2UsU0FBWDs7QUFFQSxRQUFJZixJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNkLFVBQUlHLEtBQUosRUFBVztBQUNULFlBQUlhLGNBQUosRUFBb0I7QUFDbEJoQixVQUFBQSxJQUFJLEdBQUdrQixRQUFRLENBQUNGLGNBQUQsRUFBaUIsRUFBakIsQ0FBZjtBQUNEOztBQUVELFlBQUksQ0FBQ2hCLElBQUwsRUFBVztBQUNUQSxVQUFBQSxJQUFJLEdBQUcsS0FBUDtBQUNEO0FBQ0YsT0FSRCxNQVFPO0FBQ0wsWUFBSWlCLGVBQUosRUFBcUI7QUFDbkJqQixVQUFBQSxJQUFJLEdBQUdrQixRQUFRLENBQUNELGVBQUQsRUFBa0IsRUFBbEIsQ0FBZjtBQUNEOztBQUVELFlBQUksQ0FBQ2pCLElBQUwsRUFBVztBQUNUQSxVQUFBQSxJQUFJLEdBQUcsS0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFPQSxJQUFQO0FBQ0Q7O0FBN0lnQjs7QUFtS25CLGVBQWVtQixZQUFmLENBQTZCQyxXQUE3QixFQUEwQ3RDLE9BQTFDLEVBQW1EckIsSUFBSSxHQUFHLEVBQTFELEVBQThEO0FBQzVELE1BQUksQ0FBQ3NCLGNBQUtzQyxVQUFMLENBQWdCdkMsT0FBaEIsQ0FBTCxFQUErQjtBQUM3QixVQUFNLElBQUljLEtBQUosQ0FBVyxnQkFBZWQsT0FBUSw4QkFBbEMsQ0FBTjtBQUNEOztBQUVELFFBQU1JLGFBQUdDLEtBQUgsQ0FBU0wsT0FBVCxFQUFrQjtBQUFDTSxJQUFBQSxTQUFTLEVBQUU7QUFBWixHQUFsQixDQUFOO0FBQ0EsUUFBTWhCLEdBQUcsR0FBRyxNQUFNYyxhQUFHSSxRQUFILENBQVlSLE9BQVosQ0FBbEI7O0FBQ0EsTUFBSXJCLElBQUksQ0FBQzZELGNBQVQsRUFBeUI7QUFDdkIsUUFBSTtBQUNGLFlBQU1DLHNCQUFzQixDQUFDSCxXQUFELEVBQWNoRCxHQUFkLENBQTVCO0FBQ0E7QUFDRCxLQUhELENBR0UsT0FBT08sR0FBUCxFQUFZO0FBQ1o2QyxzQkFBSUMsSUFBSixDQUFTLHNDQUFULEVBQWlEOUMsR0FBRyxDQUFDK0MsTUFBSixJQUFjL0MsR0FBRyxDQUFDZ0QsT0FBbkU7QUFDRDtBQUNGOztBQUNELFFBQU1DLFNBQVMsR0FBRyxJQUFJdEUsWUFBSixDQUFpQjhELFdBQWpCLEVBQThCLEVBQzlDLEdBQUczRCxJQUQyQztBQUU5Q1csSUFBQUE7QUFGOEMsR0FBOUIsQ0FBbEI7QUFJQSxRQUFNd0QsU0FBUyxDQUFDekQsT0FBVixFQUFOO0FBQ0Q7O0FBV0QsZUFBZW9ELHNCQUFmLENBQXVDSCxXQUF2QyxFQUFvRHRDLE9BQXBELEVBQTZEO0FBQzNELFFBQU0rQyxhQUFhLEdBQUcsd0JBQXRCO0FBQ0EsTUFBSUMsY0FBSjs7QUFDQSxNQUFJO0FBQ0ZBLElBQUFBLGNBQWMsR0FBRyxNQUFNQyxpQkFBaUIsQ0FDdENGLGFBQWEsR0FBRyxnQkFBSCxHQUFzQixPQURHLENBQXhDO0FBR0QsR0FKRCxDQUlFLE9BQU9HLENBQVAsRUFBVTtBQUNWLFVBQU0sSUFBSXBDLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ0Q7O0FBRUQsTUFBSWlDLGFBQUosRUFBbUI7QUFFakIsVUFBTSx3QkFBS0MsY0FBTCxFQUFxQixDQUN6QixVQUR5QixFQUNiLGdCQURhLEVBRXpCLGNBRnlCLEVBRVRWLFdBRlMsRUFHekIsa0JBSHlCLEVBR0x0QyxPQUhLLEVBSXpCLFFBSnlCLENBQXJCLENBQU47QUFNRCxHQVJELE1BUU87QUFJTCxVQUFNLHdCQUFLZ0QsY0FBTCxFQUFxQixDQUN6QixJQUR5QixFQUV6QixJQUZ5QixFQUVuQlYsV0FGbUIsRUFHekIsSUFIeUIsRUFHbkJ0QyxPQUhtQixDQUFyQixDQUFOO0FBS0Q7QUFDRjs7QUFTRCxlQUFlbUQsZUFBZixDQUFnQ0MsT0FBaEMsRUFBeUNyRSxLQUF6QyxFQUFnRGlCLE9BQWhELEVBQXlEO0FBQ3ZELFFBQU1xRCxPQUFPLEdBQUdwRCxjQUFLUCxPQUFMLENBQWFNLE9BQWIsRUFBc0JqQixLQUFLLENBQUNHLFFBQTVCLENBQWhCOztBQUdBLE1BQUksTUFBTW9FLElBQU4sQ0FBV3ZFLEtBQUssQ0FBQ0csUUFBakIsQ0FBSixFQUFnQztBQUM5QixRQUFJLEVBQUMsTUFBTWtCLGFBQUdtRCxNQUFILENBQVVGLE9BQVYsQ0FBUCxDQUFKLEVBQStCO0FBQzdCLFlBQU0sb0JBQU9BLE9BQVAsQ0FBTjtBQUNEOztBQUNEO0FBQ0QsR0FMRCxNQUtPLElBQUksRUFBQyxNQUFNakQsYUFBR21ELE1BQUgsQ0FBVXRELGNBQUtDLE9BQUwsQ0FBYW1ELE9BQWIsQ0FBVixDQUFQLENBQUosRUFBNkM7QUFDbEQsVUFBTSxvQkFBT3BELGNBQUtDLE9BQUwsQ0FBYW1ELE9BQWIsQ0FBUCxDQUFOO0FBQ0Q7O0FBR0QsUUFBTUcsV0FBVyxHQUFHLDJCQUFrQkgsT0FBbEIsRUFBMkI7QUFBQ0ksSUFBQUEsS0FBSyxFQUFFO0FBQVIsR0FBM0IsQ0FBcEI7QUFDQSxRQUFNQyxrQkFBa0IsR0FBRyxJQUFJNUYsaUJBQUosQ0FBTSxDQUFDNEIsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3BENkQsSUFBQUEsV0FBVyxDQUFDRyxJQUFaLENBQWlCLFFBQWpCLEVBQTJCakUsT0FBM0I7QUFDQThELElBQUFBLFdBQVcsQ0FBQ0csSUFBWixDQUFpQixPQUFqQixFQUEwQmhFLE1BQTFCO0FBQ0QsR0FIMEIsQ0FBM0I7QUFPQSxRQUFNaUUsYUFBYSxHQUFHLE1BQU0sSUFBSTlGLGlCQUFKLENBQU0sQ0FBQzRCLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUNyRHlELElBQUFBLE9BQU8sQ0FBQ3hCLGNBQVIsQ0FBdUI3QyxLQUF2QixFQUE4QixDQUFDYyxHQUFELEVBQU04QixVQUFOLEtBQXFCOUIsR0FBRyxHQUFHRixNQUFNLENBQUNFLEdBQUQsQ0FBVCxHQUFpQkgsT0FBTyxDQUFDaUMsVUFBRCxDQUE5RTtBQUNELEdBRjJCLENBQTVCO0FBR0EsUUFBTWtDLG9CQUFvQixHQUFHLElBQUkvRixpQkFBSixDQUFNLENBQUM0QixPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdERpRSxJQUFBQSxhQUFhLENBQUNELElBQWQsQ0FBbUIsS0FBbkIsRUFBMEJqRSxPQUExQjtBQUNBa0UsSUFBQUEsYUFBYSxDQUFDRCxJQUFkLENBQW1CLE9BQW5CLEVBQTRCaEUsTUFBNUI7QUFDRCxHQUg0QixDQUE3QjtBQUlBaUUsRUFBQUEsYUFBYSxDQUFDRSxJQUFkLENBQW1CTixXQUFuQjtBQUdBLFNBQU8sTUFBTTFGLGtCQUFFaUcsR0FBRixDQUFNLENBQ2pCRixvQkFEaUIsRUFFakJILGtCQUZpQixDQUFOLENBQWI7QUFJRDs7QUFrQkQsZUFBZU0sV0FBZixDQUE0QjFCLFdBQTVCLEVBQXlDMkIsT0FBekMsRUFBa0Q7QUFFaEQsUUFBTTFFLE9BQU8sR0FBRyxNQUFNMUIsT0FBTyxDQUFDeUUsV0FBRCxFQUFjO0FBQUM5QyxJQUFBQSxXQUFXLEVBQUU7QUFBZCxHQUFkLENBQTdCO0FBQ0EsUUFBTXFFLG9CQUFvQixHQUFHLElBQUkvRixpQkFBSixDQUFNLENBQUM0QixPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdERKLElBQUFBLE9BQU8sQ0FBQ29FLElBQVIsQ0FBYSxLQUFiLEVBQW9CakUsT0FBcEI7QUFDQUgsSUFBQUEsT0FBTyxDQUFDb0UsSUFBUixDQUFhLE9BQWIsRUFBc0JoRSxNQUF0QjtBQUdBSixJQUFBQSxPQUFPLENBQUNLLEVBQVIsQ0FBVyxPQUFYLEVBQW9CLE1BQU9iLEtBQVAsSUFBaUI7QUFDbkMsWUFBTW1GLEdBQUcsR0FBRyxNQUFNRCxPQUFPLENBQUM7QUFDeEJsRixRQUFBQSxLQUR3QjtBQUV4Qm9GLFFBQUFBLGNBQWMsRUFBRSxNQUFPbkUsT0FBUCxJQUFtQixNQUFNbUQsZUFBZSxDQUFDNUQsT0FBRCxFQUFVUixLQUFWLEVBQWlCaUIsT0FBakI7QUFGaEMsT0FBRCxDQUF6Qjs7QUFJQSxVQUFJa0UsR0FBRyxLQUFLLEtBQVosRUFBbUI7QUFDakIsZUFBTzNFLE9BQU8sQ0FBQzZFLElBQVIsQ0FBYSxLQUFiLENBQVA7QUFDRDs7QUFDRDdFLE1BQUFBLE9BQU8sQ0FBQ08sU0FBUjtBQUNELEtBVEQ7QUFVRCxHQWY0QixDQUE3QjtBQWdCQVAsRUFBQUEsT0FBTyxDQUFDTyxTQUFSO0FBR0EsU0FBTyxNQUFNK0Qsb0JBQWI7QUFDRDs7QUE0QkQsZUFBZVEsYUFBZixDQUE4QkMsT0FBOUIsRUFBdUMzRixJQUFJLEdBQUcsRUFBOUMsRUFBa0Q7QUFDaEQsTUFBSSxFQUFDLE1BQU15QixhQUFHbUQsTUFBSCxDQUFVZSxPQUFWLENBQVAsQ0FBSixFQUErQjtBQUM3QixVQUFNLElBQUl4RCxLQUFKLENBQVcsMkJBQTBCd0QsT0FBUSxFQUE3QyxDQUFOO0FBQ0Q7O0FBRUQsUUFBTTtBQUNKQyxJQUFBQSxTQUFTLEdBQUcsSUFEUjtBQUVKQyxJQUFBQSxjQUFjLEdBQUcsS0FGYjtBQUdKQyxJQUFBQSxPQUFPLEdBQUcsSUFBSUMsU0FIVjtBQUlKQyxJQUFBQSxLQUFLLEdBQUc7QUFKSixNQUtGaEcsSUFMSjtBQU1BLFFBQU1pRyxhQUFhLEdBQUcsRUFBdEI7QUFDQSxNQUFJQyxpQkFBaUIsR0FBRyxDQUF4QjtBQUVBLFFBQU1DLGlCQUFpQixHQUFHLElBQUkzRyxnQkFBTzRHLFFBQVgsQ0FBb0I7QUFDNUNDLElBQUFBLEtBQUssRUFBRSxDQUFDQyxNQUFELEVBQVNDLFFBQVQsRUFBbUJDLElBQW5CLEtBQTRCO0FBQ2pDUCxNQUFBQSxhQUFhLENBQUNRLElBQWQsQ0FBbUJILE1BQW5CO0FBQ0FKLE1BQUFBLGlCQUFpQixJQUFJSSxNQUFNLENBQUNJLE1BQTVCOztBQUNBLFVBQUlaLE9BQU8sR0FBRyxDQUFWLElBQWVJLGlCQUFpQixHQUFHSixPQUF2QyxFQUFnRDtBQUM5Q0ssUUFBQUEsaUJBQWlCLENBQUNWLElBQWxCLENBQXVCLE9BQXZCLEVBQWdDLElBQUl0RCxLQUFKLENBQVcsNEJBQUQsR0FDdkMsb0NBQW1DLGdDQUFxQjJELE9BQXJCLENBQThCLEVBRHBDLENBQWhDO0FBRUQ7O0FBQ0RVLE1BQUFBLElBQUk7QUFDTDtBQVQyQyxHQUFwQixDQUExQjtBQWFBLFFBQU1HLE9BQU8sR0FBRyx1QkFBUyxLQUFULEVBQWdCO0FBQzlCQyxJQUFBQSxJQUFJLEVBQUU7QUFBQ1osTUFBQUE7QUFBRDtBQUR3QixHQUFoQixDQUFoQjtBQUdBLE1BQUlhLE9BQU8sR0FBRyxJQUFkO0FBQ0EsUUFBTUMsbUJBQW1CLEdBQUdqQixjQUFjLEdBQUcsSUFBSWtCLDBCQUFKLEVBQUgsR0FBd0IsSUFBbEU7QUFDQSxRQUFNQyx3QkFBd0IsR0FBRyxJQUFJN0gsaUJBQUosQ0FBTSxDQUFDNEIsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQzFEbUYsSUFBQUEsaUJBQWlCLENBQUNuQixJQUFsQixDQUF1QixPQUF2QixFQUFpQ1QsQ0FBRCxJQUFPO0FBQ3JDLFVBQUl1QyxtQkFBSixFQUF5QjtBQUN2QkgsUUFBQUEsT0FBTyxDQUFDTSxNQUFSLENBQWVILG1CQUFmO0FBQ0FBLFFBQUFBLG1CQUFtQixDQUFDRyxNQUFwQixDQUEyQmQsaUJBQTNCO0FBQ0QsT0FIRCxNQUdPO0FBQ0xRLFFBQUFBLE9BQU8sQ0FBQ00sTUFBUixDQUFlZCxpQkFBZjtBQUNEOztBQUNEUSxNQUFBQSxPQUFPLENBQUNPLEtBQVI7QUFDQVAsTUFBQUEsT0FBTyxDQUFDUSxPQUFSO0FBQ0FuRyxNQUFBQSxNQUFNLENBQUN1RCxDQUFELENBQU47QUFDRCxLQVZEO0FBV0E0QixJQUFBQSxpQkFBaUIsQ0FBQ25CLElBQWxCLENBQXVCLFFBQXZCLEVBQWlDLE1BQU07QUFDckM2QixNQUFBQSxPQUFPLEdBQUdGLE9BQU8sQ0FBQ1MsT0FBUixFQUFWO0FBQ0FyRyxNQUFBQSxPQUFPO0FBQ1IsS0FIRDtBQUlELEdBaEJnQyxDQUFqQztBQWlCQSxRQUFNc0csb0JBQW9CLEdBQUcsSUFBSWxJLGlCQUFKLENBQU0sQ0FBQzRCLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0RDJGLElBQUFBLE9BQU8sQ0FBQzNCLElBQVIsQ0FBYSxRQUFiLEVBQXVCakUsT0FBdkI7QUFDQTRGLElBQUFBLE9BQU8sQ0FBQzNCLElBQVIsQ0FBYSxPQUFiLEVBQXVCVCxDQUFELElBQU92RCxNQUFNLENBQ2pDLElBQUltQixLQUFKLENBQVcsc0JBQXFCd0QsT0FBUSxNQUFLcEIsQ0FBQyxDQUFDTCxPQUFRLEVBQXZELENBRGlDLENBQW5DO0FBRUQsR0FKNEIsQ0FBN0I7QUFLQSxRQUFNb0QsS0FBSyxHQUFHMUIsU0FBUyxHQUFHLElBQUkyQixlQUFKLEdBQVlDLEtBQVosRUFBSCxHQUF5QixJQUFoRDs7QUFDQSxNQUFJLENBQUMsTUFBTS9GLGFBQUdnRyxJQUFILENBQVE5QixPQUFSLENBQVAsRUFBeUIrQixXQUF6QixFQUFKLEVBQTRDO0FBQzFDZixJQUFBQSxPQUFPLENBQUNnQixTQUFSLENBQWtCaEMsT0FBbEIsRUFBMkIsS0FBM0I7QUFDRCxHQUZELE1BRU87QUFDTGdCLElBQUFBLE9BQU8sQ0FBQ2lCLElBQVIsQ0FBYWpDLE9BQWIsRUFBc0I7QUFDcEJrQyxNQUFBQSxJQUFJLEVBQUV2RyxjQUFLd0csUUFBTCxDQUFjbkMsT0FBZDtBQURjLEtBQXRCO0FBR0Q7O0FBQ0QsTUFBSW1CLG1CQUFKLEVBQXlCO0FBQ3ZCSCxJQUFBQSxPQUFPLENBQUN4QixJQUFSLENBQWEyQixtQkFBYjtBQUNBQSxJQUFBQSxtQkFBbUIsQ0FBQzNCLElBQXBCLENBQXlCZ0IsaUJBQXpCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xRLElBQUFBLE9BQU8sQ0FBQ3hCLElBQVIsQ0FBYWdCLGlCQUFiO0FBQ0Q7O0FBQ0RRLEVBQUFBLE9BQU8sQ0FBQ29CLFFBQVI7QUFHQSxRQUFNNUksa0JBQUVpRyxHQUFGLENBQU0sQ0FBQ2lDLG9CQUFELEVBQXVCTCx3QkFBdkIsQ0FBTixDQUFOOztBQUVBLE1BQUlNLEtBQUosRUFBVztBQUNUdkQsb0JBQUlpRSxLQUFKLENBQVcsVUFBU25DLGNBQWMsR0FBRyxxQkFBSCxHQUEyQixFQUFHLEVBQXRELEdBQ1AsSUFBR3ZFLGNBQUt3RyxRQUFMLENBQWNuQyxPQUFkLENBQXVCLElBRG5CLElBRVBrQixPQUFPLEdBQUksSUFBRyxnQ0FBcUJBLE9BQXJCLENBQThCLElBQXJDLEdBQTJDLEVBRjNDLElBR1AsTUFBS1MsS0FBSyxDQUFDVyxXQUFOLEdBQW9CQyxTQUFwQixDQUE4QkMsT0FBOUIsQ0FBc0MsQ0FBdEMsQ0FBeUMsSUFIdkMsR0FJUCx1QkFBc0JuQyxLQUFNLEdBSi9CO0FBS0Q7O0FBRUQsU0FBT29DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjcEMsYUFBZCxDQUFQO0FBQ0Q7O0FBUUQsZUFBZXFDLGNBQWYsQ0FBK0JDLFFBQS9CLEVBQXlDO0FBQ3ZDLE1BQUksRUFBQyxNQUFNOUcsYUFBR21ELE1BQUgsQ0FBVTJELFFBQVYsQ0FBUCxDQUFKLEVBQWdDO0FBQzlCLFVBQU0sSUFBSXBHLEtBQUosQ0FBVyxnQkFBZW9HLFFBQVMsa0JBQW5DLENBQU47QUFDRDs7QUFFRCxRQUFNO0FBQUNDLElBQUFBO0FBQUQsTUFBUyxNQUFNL0csYUFBR2dHLElBQUgsQ0FBUWMsUUFBUixDQUFyQjs7QUFDQSxNQUFJQyxJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1osVUFBTSxJQUFJckcsS0FBSixDQUFXLGdCQUFlb0csUUFBUyxvQ0FBbkMsQ0FBTjtBQUNEOztBQUNELFFBQU1FLEVBQUUsR0FBRyxNQUFNaEgsYUFBR25DLElBQUgsQ0FBUWlKLFFBQVIsRUFBa0IsR0FBbEIsQ0FBakI7O0FBQ0EsTUFBSTtBQUNGLFVBQU1qQyxNQUFNLEdBQUc4QixNQUFNLENBQUNNLEtBQVAsQ0FBYWpKLFNBQVMsQ0FBQ2lILE1BQXZCLENBQWY7QUFDQSxVQUFNakYsYUFBR2tILElBQUgsQ0FBUUYsRUFBUixFQUFZbkMsTUFBWixFQUFvQixDQUFwQixFQUF1QjdHLFNBQVMsQ0FBQ2lILE1BQWpDLEVBQXlDLENBQXpDLENBQU47QUFDQSxVQUFNa0MsU0FBUyxHQUFHdEMsTUFBTSxDQUFDOUYsUUFBUCxDQUFnQixPQUFoQixDQUFsQjs7QUFDQSxRQUFJb0ksU0FBUyxLQUFLbkosU0FBbEIsRUFBNkI7QUFDM0IsWUFBTSxJQUFJMEMsS0FBSixDQUFXLHVCQUFzQnlHLFNBQVUsU0FBUUwsUUFBUyxJQUFsRCxHQUNiLHVEQUFzRDlJLFNBQVUsR0FEN0QsQ0FBTjtBQUVEOztBQUNELFdBQU8sSUFBUDtBQUNELEdBVEQsU0FTVTtBQUNSLFVBQU1nQyxhQUFHWSxLQUFILENBQVNvRyxFQUFULENBQU47QUFDRDtBQUNGOztBQXdCRCxlQUFlSSxTQUFmLENBQTBCbkUsT0FBMUIsRUFBbUNvRSxHQUFHLEdBQUcsRUFBekMsRUFBNkM5SSxJQUFJLEdBQUcsRUFBcEQsRUFBd0Q7QUFDdEQsUUFBTTtBQUNKZ0csSUFBQUEsS0FBSyxHQUFHO0FBREosTUFFRmhHLElBRko7QUFHQSxRQUFNO0FBQ0orSSxJQUFBQSxPQUFPLEdBQUcsTUFETjtBQUVKQyxJQUFBQSxHQUFHLEdBQUcxSCxjQUFLQyxPQUFMLENBQWFtRCxPQUFiLENBRkY7QUFHSnVFLElBQUFBLE1BQU0sR0FBRztBQUhMLE1BSUZILEdBSko7QUFLQSxRQUFNbkMsT0FBTyxHQUFHLHVCQUFTLEtBQVQsRUFBZ0I7QUFBRUMsSUFBQUEsSUFBSSxFQUFFO0FBQUVaLE1BQUFBO0FBQUY7QUFBUixHQUFoQixDQUFoQjs7QUFDQSxRQUFNeEcsTUFBTSxHQUFHaUMsYUFBRzRCLGlCQUFILENBQXFCcUIsT0FBckIsQ0FBZjs7QUFDQSxTQUFPLE1BQU0sSUFBSXZGLGlCQUFKLENBQU0sQ0FBQzRCLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0QzJGLElBQUFBLE9BQU8sQ0FDSnVDLElBREgsQ0FDUUgsT0FEUixFQUNpQjtBQUNiQyxNQUFBQSxHQURhO0FBRWJDLE1BQUFBO0FBRmEsS0FEakIsRUFLR2hJLEVBTEgsQ0FLTSxPQUxOLEVBS2VELE1BTGYsRUFNR21FLElBTkgsQ0FNUTNGLE1BTlI7QUFPQUEsSUFBQUEsTUFBTSxDQUNIeUIsRUFESCxDQUNNLE9BRE4sRUFDZ0JzRCxDQUFELElBQU87QUFDbEJvQyxNQUFBQSxPQUFPLENBQUNNLE1BQVIsQ0FBZXpILE1BQWY7QUFDQW1ILE1BQUFBLE9BQU8sQ0FBQ08sS0FBUjtBQUNBUCxNQUFBQSxPQUFPLENBQUNRLE9BQVI7QUFDQW5HLE1BQUFBLE1BQU0sQ0FBQ3VELENBQUQsQ0FBTjtBQUNELEtBTkgsRUFPR3RELEVBUEgsQ0FPTSxRQVBOLEVBT2dCRixPQVBoQjtBQVFBNEYsSUFBQUEsT0FBTyxDQUFDb0IsUUFBUjtBQUNELEdBakJZLENBQWI7QUFrQkQ7O0FBTUQsTUFBTXpELGlCQUFpQixHQUFHakUsZ0JBQUU4SSxPQUFGLENBSXhCLGVBQWU3RSxpQkFBZixDQUFrQzhFLFVBQWxDLEVBQThDO0FBQzVDLFFBQU1DLFFBQVEsR0FBRyxNQUFNNUgsYUFBRzZILEtBQUgsQ0FBU0YsVUFBVCxDQUF2Qjs7QUFDQXJGLGtCQUFJaUUsS0FBSixDQUFXLG9CQUFYLEVBQWdDb0IsVUFBaEMsRUFBNENDLFFBQTVDOztBQUNBLFNBQU9BLFFBQVA7QUFDRCxDQVJ1QixDQUExQjs7ZUFhZTtBQUFFM0YsRUFBQUEsWUFBRjtBQUFnQjJCLEVBQUFBLFdBQWhCO0FBQTZCSyxFQUFBQSxhQUE3QjtBQUE0QzRDLEVBQUFBLGNBQTVDO0FBQTRETyxFQUFBQTtBQUE1RCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB5YXV6bCBmcm9tICd5YXV6bCc7XG5pbXBvcnQgYXJjaGl2ZXIgZnJvbSAnYXJjaGl2ZXInO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGVTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IG1rZGlycCB9IGZyb20gJy4uL2xpYi9ta2RpcnAnO1xuaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IGZzIGZyb20gJy4vZnMnO1xuaW1wb3J0IHsgaXNXaW5kb3dzIH0gZnJvbSAnLi9zeXN0ZW0nO1xuaW1wb3J0IHsgQmFzZTY0RW5jb2RlIH0gZnJvbSAnYmFzZTY0LXN0cmVhbSc7XG5pbXBvcnQgeyB0b1JlYWRhYmxlU2l6ZVN0cmluZywgR2lCIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBUaW1lciBmcm9tICcuL3RpbWluZyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBnZXRTdHJlYW0gZnJvbSAnZ2V0LXN0cmVhbSc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcblxuY29uc3Qgb3BlblppcCA9IEIucHJvbWlzaWZ5KHlhdXpsLm9wZW4pO1xuY29uc3QgcGlwZWxpbmUgPSBCLnByb21pc2lmeShzdHJlYW0ucGlwZWxpbmUpO1xuY29uc3QgWklQX01BR0lDID0gJ1BLJztcbmNvbnN0IElGTVQgPSA2MTQ0MDtcbmNvbnN0IElGRElSID0gMTYzODQ7XG5jb25zdCBJRkxOSyA9IDQwOTYwO1xuXG4vLyBUaGlzIGNsYXNzIGlzIG1vc3RseSBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vZXh0cmFjdC16aXAvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmNsYXNzIFppcEV4dHJhY3RvciB7XG4gIGNvbnN0cnVjdG9yIChzb3VyY2VQYXRoLCBvcHRzID0ge30pIHtcbiAgICB0aGlzLnppcFBhdGggPSBzb3VyY2VQYXRoO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZXh0cmFjdEZpbGVOYW1lIChlbnRyeSkge1xuICAgIHJldHVybiBfLmlzQnVmZmVyKGVudHJ5LmZpbGVOYW1lKSA/IGVudHJ5LmZpbGVOYW1lLnRvU3RyaW5nKHRoaXMub3B0cy5maWxlTmFtZXNFbmNvZGluZykgOiBlbnRyeS5maWxlTmFtZTtcbiAgfVxuXG4gIGFzeW5jIGV4dHJhY3QgKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcixcbiAgICAgIGZpbGVOYW1lc0VuY29kaW5nLFxuICAgIH0gPSB0aGlzLm9wdHM7XG4gICAgdGhpcy56aXBmaWxlID0gYXdhaXQgb3BlblppcCh0aGlzLnppcFBhdGgsIHtcbiAgICAgIGxhenlFbnRyaWVzOiB0cnVlLFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RoZWpvc2h3b2xmZS95YXV6bC9jb21taXQvY2M3NDU1YWM3ODliYTg0OTczMTg0ZTVlYmRlMDU4MWNkYzRjM2IzOSNkaWZmLTA0YzZlOTBmYWFjMjY3NWFhODllMjE3NmQyZWVjN2Q4Ujk1XG4gICAgICBkZWNvZGVTdHJpbmdzOiAhZmlsZU5hbWVzRW5jb2RpbmcsXG4gICAgfSk7XG4gICAgdGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuemlwZmlsZS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy56aXBmaWxlLnJlYWRFbnRyeSgpO1xuXG4gICAgICB0aGlzLnppcGZpbGUub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnppcGZpbGUub24oJ2VudHJ5JywgYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmV4dHJhY3RGaWxlTmFtZShlbnRyeSk7XG4gICAgICAgIGlmIChmaWxlTmFtZS5zdGFydHNXaXRoKCdfX01BQ09TWC8nKSkge1xuICAgICAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXN0RGlyID0gcGF0aC5kaXJuYW1lKHBhdGguam9pbihkaXIsIGZpbGVOYW1lKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZnMubWtkaXIoZGVzdERpciwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuXG4gICAgICAgICAgY29uc3QgY2Fub25pY2FsRGVzdERpciA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlc3REaXIpO1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlRGVzdERpciA9IHBhdGgucmVsYXRpdmUoZGlyLCBjYW5vbmljYWxEZXN0RGlyKTtcblxuICAgICAgICAgIGlmIChyZWxhdGl2ZURlc3REaXIuc3BsaXQocGF0aC5zZXApLmluY2x1ZGVzKCcuLicpKSB7XG4gICAgICAgICAgICBuZXcgRXJyb3IoYE91dCBvZiBib3VuZCBwYXRoIFwiJHtjYW5vbmljYWxEZXN0RGlyfVwiIGZvdW5kIHdoaWxlIHByb2Nlc3NpbmcgZmlsZSAke2ZpbGVOYW1lfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB0aGlzLnppcGZpbGUucmVhZEVudHJ5KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuemlwZmlsZS5jbG9zZSgpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGV4dHJhY3RFbnRyeSAoZW50cnkpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRpcixcbiAgICB9ID0gdGhpcy5vcHRzO1xuXG4gICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmV4dHJhY3RGaWxlTmFtZShlbnRyeSk7XG4gICAgY29uc3QgZGVzdCA9IHBhdGguam9pbihkaXIsIGZpbGVOYW1lKTtcblxuICAgIC8vIGNvbnZlcnQgZXh0ZXJuYWwgZmlsZSBhdHRyIGludCBpbnRvIGEgZnMgc3RhdCBtb2RlIGludFxuICAgIGNvbnN0IG1vZGUgPSAoZW50cnkuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweEZGRkY7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBhIHN5bWxpbmsgb3IgZGlyICh1c2luZyBzdGF0IG1vZGUgY29uc3RhbnRzKVxuICAgIGNvbnN0IGlzU3ltbGluayA9IChtb2RlICYgSUZNVCkgPT09IElGTE5LO1xuICAgIGNvbnN0IGlzRGlyID0gKG1vZGUgJiBJRk1UKSA9PT0gSUZESVJcbiAgICAgIC8vIEZhaWxzYWZlLCBib3Jyb3dlZCBmcm9tIGpzWmlwXG4gICAgICB8fCBmaWxlTmFtZS5lbmRzV2l0aCgnLycpXG4gICAgICAvLyBjaGVjayBmb3Igd2luZG93cyB3ZWlyZCB3YXkgb2Ygc3BlY2lmeWluZyBhIGRpcmVjdG9yeVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL2V4dHJhY3QtemlwL2lzc3Vlcy8xMyNpc3N1ZWNvbW1lbnQtMTU0NDk0NTY2XG4gICAgICB8fCAoZW50cnkudmVyc2lvbk1hZGVCeSA+PiA4ID09PSAwICYmIGVudHJ5LmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPT09IDE2KTtcbiAgICBjb25zdCBwcm9jTW9kZSA9IHRoaXMuZ2V0RXh0cmFjdGVkTW9kZShtb2RlLCBpc0RpcikgJiAwbzc3NztcbiAgICAvLyBhbHdheXMgZW5zdXJlIGZvbGRlcnMgYXJlIGNyZWF0ZWRcbiAgICBjb25zdCBkZXN0RGlyID0gaXNEaXIgPyBkZXN0IDogcGF0aC5kaXJuYW1lKGRlc3QpO1xuICAgIGNvbnN0IG1rZGlyT3B0aW9ucyA9IHsgcmVjdXJzaXZlOiB0cnVlIH07XG4gICAgaWYgKGlzRGlyKSB7XG4gICAgICBta2Rpck9wdGlvbnMubW9kZSA9IHByb2NNb2RlO1xuICAgIH1cbiAgICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCBta2Rpck9wdGlvbnMpO1xuICAgIGlmIChpc0Rpcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBhd2FpdCBCLnByb21pc2lmeSh0aGlzLnppcGZpbGUub3BlblJlYWRTdHJlYW0uYmluZCh0aGlzLnppcGZpbGUpKShlbnRyeSk7XG4gICAgaWYgKGlzU3ltbGluaykge1xuICAgICAgY29uc3QgbGluayA9IGF3YWl0IGdldFN0cmVhbShyZWFkU3RyZWFtKTtcbiAgICAgIGF3YWl0IGZzLnN5bWxpbmsobGluaywgZGVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHBpcGVsaW5lKHJlYWRTdHJlYW0sIGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3QsIHsgbW9kZTogcHJvY01vZGUgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGdldEV4dHJhY3RlZE1vZGUgKGVudHJ5TW9kZSwgaXNEaXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZWZhdWx0RGlyTW9kZSxcbiAgICAgIGRlZmF1bHRGaWxlTW9kZSxcbiAgICB9ID0gdGhpcy5vcHRzO1xuXG4gICAgbGV0IG1vZGUgPSBlbnRyeU1vZGU7XG4gICAgLy8gU2V0IGRlZmF1bHRzLCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kZSA9PT0gMCkge1xuICAgICAgaWYgKGlzRGlyKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RGlyTW9kZSkge1xuICAgICAgICAgIG1vZGUgPSBwYXJzZUludChkZWZhdWx0RGlyTW9kZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IDBvNzU1O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVmYXVsdEZpbGVNb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IHBhcnNlSW50KGRlZmF1bHRGaWxlTW9kZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgbW9kZSA9IDBvNjQ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGU7XG4gIH1cbn1cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV4dHJhY3RBbGxPcHRpb25zXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGZpbGVOYW1lc0VuY29kaW5nIFRoZSBlbmNvZGluZyB0byB1c2UgZm9yIGV4dHJhY3RlZCBmaWxlIG5hbWVzLlxuICogRm9yIFpJUCBhcmNoaXZlcyBjcmVhdGVkIG9uIE1hY09TIGl0IGlzIHVzdWFsbHkgZXhwZWN0ZWQgdG8gYmUgYHV0ZjhgLlxuICogQnkgZGVmYXVsdCBpdCBpcyBhdXRvZGV0ZWN0ZWQgYmFzZWQgb24gdGhlIGVudHJ5IG1ldGFkYXRhIGFuZCBpcyBvbmx5IG5lZWRlZCB0byBiZSBzZXQgZXhwbGljaXRseVxuICogaWYgdGhlIHBhcnRpY3VsYXIgYXJjaGl2ZSBkb2VzIG5vdCBjb21wbHkgdG8gdGhlIHN0YW5kYXJkcywgd2hpY2ggbGVhZHMgdG8gY29ycnVwdGVkIGZpbGUgbmFtZXNcbiAqIGFmdGVyIGV4dHJhY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBpZiBzeXN0ZW0gdW56aXAgYmluYXJ5IGlzIE5PVCBiZWluZyB1c2VkLlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdXNlU3lzdGVtVW56aXAgW2ZhbHNlXSBJZiB0cnVlLCBhdHRlbXB0IHRvIHVzZSBzeXN0ZW0gdW56aXA7IGlmIHRoaXMgZmFpbHMsXG4gKiBmYWxsYmFjayB0byB0aGUgSlMgdW56aXAgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHppcGZpbGUgdG8gYSBkaXJlY3RvcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqIEBwYXJhbSB7P0V4dHJhY3RBbGxPcHRpb25zfSBvcHRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBbGxUbyAoemlwRmlsZVBhdGgsIGRlc3REaXIsIG9wdHMgPSB7fSkge1xuICBpZiAoIXBhdGguaXNBYnNvbHV0ZShkZXN0RGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHBhdGggJyR7ZGVzdERpcn0nIGlzIGV4cGVjdGVkIHRvIGJlIGFic29sdXRlYCk7XG4gIH1cblxuICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gIGNvbnN0IGRpciA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlc3REaXIpO1xuICBpZiAob3B0cy51c2VTeXN0ZW1VbnppcCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleHRyYWN0V2l0aFN5c3RlbVVuemlwKHppcEZpbGVQYXRoLCBkaXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oJ3VuemlwIGZhaWxlZDsgZmFsbGluZyBiYWNrIHRvIEpTOiAlcycsIGVyci5zdGRlcnIgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBjb25zdCBleHRyYWN0b3IgPSBuZXcgWmlwRXh0cmFjdG9yKHppcEZpbGVQYXRoLCB7XG4gICAgLi4ub3B0cyxcbiAgICBkaXIsXG4gIH0pO1xuICBhd2FpdCBleHRyYWN0b3IuZXh0cmFjdCgpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHN5c3RlbSB1bnppcCAoZS5nLiwgYC91c3IvYmluL3VuemlwYCkuIElmIGF2YWlsYWJsZSwgaXQgaXNcbiAqIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gdGhlIEpTIGltcGxlbWVudGF0aW9uLlxuICogQnkgZGVmYXVsdCBhbGwgZmlsZXMgaW4gdGhlIGRlc3REaXIgZ2V0IG92ZXJyaWRkZW4gaWYgYWxyZWFkeSBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIuXG4gKiBUaGlzIGZvbGRlciBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGV4aXN0IGJlZm9yZSBleHRyYWN0aW5nIHRoZSBhcmNoaXZlLlxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aFN5c3RlbVVuemlwICh6aXBGaWxlUGF0aCwgZGVzdERpcikge1xuICBjb25zdCBpc1dpbmRvd3NIb3N0ID0gaXNXaW5kb3dzKCk7XG4gIGxldCBleGVjdXRhYmxlUGF0aDtcbiAgdHJ5IHtcbiAgICBleGVjdXRhYmxlUGF0aCA9IGF3YWl0IGdldEV4ZWN1dGFibGVQYXRoKFxuICAgICAgaXNXaW5kb3dzSG9zdCA/ICdwb3dlcnNoZWxsLmV4ZScgOiAndW56aXAnXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgc3lzdGVtIHVuemlwJyk7XG4gIH1cblxuICBpZiAoaXNXaW5kb3dzSG9zdCkge1xuICAgIC8vIG9uIFdpbmRvd3Mgd2UgdXNlIFBvd2VyU2hlbGwgdG8gdW56aXAgZmlsZXNcbiAgICBhd2FpdCBleGVjKGV4ZWN1dGFibGVQYXRoLCBbXG4gICAgICAnLWNvbW1hbmQnLCAnRXhwYW5kLUFyY2hpdmUnLFxuICAgICAgJy1MaXRlcmFsUGF0aCcsIHppcEZpbGVQYXRoLFxuICAgICAgJy1EZXN0aW5hdGlvblBhdGgnLCBkZXN0RGlyLFxuICAgICAgJy1Gb3JjZSdcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAtcSBtZWFucyBxdWlldCAobm8gc3Rkb3V0KVxuICAgIC8vIC1vIG1lYW5zIG92ZXJ3cml0ZVxuICAgIC8vIC1kIGlzIHRoZSBkZXN0IGRpclxuICAgIGF3YWl0IGV4ZWMoZXhlY3V0YWJsZVBhdGgsIFtcbiAgICAgICctcScsXG4gICAgICAnLW8nLCB6aXBGaWxlUGF0aCxcbiAgICAgICctZCcsIGRlc3REaXJcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgemlwIGVudHJ5IHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtTdHJlYW1hYmxlfSB6aXBGaWxlIFRoZSBzb3VyY2UgWklQIHN0cmVhbVxuICogQHBhcmFtIHt5YXV6bC5aaXBFbnRyeX0gZW50cnkgVGhlIGVudHJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4dHJhY3RFbnRyeVRvICh6aXBGaWxlLCBlbnRyeSwgZGVzdERpcikge1xuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRlc3REaXIsIGVudHJ5LmZpbGVOYW1lKTtcblxuICAvLyBDcmVhdGUgZGVzdCBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdCBhbHJlYWR5XG4gIGlmICgvXFwvJC8udGVzdChlbnRyeS5maWxlTmFtZSkpIHtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgYXdhaXQgbWtkaXJwKGRzdFBhdGgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB3cml0ZSBzdHJlYW1cbiAgY29uc3Qgd3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoLCB7ZmxhZ3M6ICd3J30pO1xuICBjb25zdCB3cml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgemlwUmVhZFN0cmVhbSBhbmQgcGlwZSBkYXRhIHRvIHRoZSB3cml0ZSBzdHJlYW1cbiAgLy8gKGZvciBzb21lIG9kZCByZWFzb24gQi5wcm9taXNpZnkgZG9lc24ndCB3b3JrIG9uIHppcGZpbGUub3BlblJlYWRTdHJlYW0sIGl0IGNhdXNlcyBhbiBlcnJvciAnY2xvc2VkJylcbiAgY29uc3QgemlwUmVhZFN0cmVhbSA9IGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBGaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVhZFN0cmVhbSkpO1xuICB9KTtcbiAgY29uc3QgemlwUmVhZFN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG4gIHppcFJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIHppcFJlYWRTdHJlYW0gYW5kIHdyaXRlU3RyZWFtIHRvIGVuZCBiZWZvcmUgcmV0dXJuaW5nXG4gIHJldHVybiBhd2FpdCBCLmFsbChbXG4gICAgemlwUmVhZFN0cmVhbVByb21pc2UsXG4gICAgd3JpdGVTdHJlYW1Qcm9taXNlLFxuICBdKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBaaXBFbnRyeVxuICogQHByb3BlcnR5IHt5YXV6bC5aaXBFbnRyeX0gZW50cnkgVGhlIGFjdHVhbCBlbnRyeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXh0cmFjdEVudHJ5VG8gQW4gYXN5bmMgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgb25lIHBhcmFtZXRlci5cbiAqIFRoaXMgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgcGF0aCB0byB3aGljaCB0aGlzIGZ1bmN0aW9uIGlzIGdvaW5nIHRvIGV4dHJhY3QgdGhlIGVudHJ5LlxuICovXG5cbi8qKlxuICogR2V0IGVudHJpZXMgZm9yIGEgemlwIGZvbGRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB6aXBGaWxlUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBzb3VyY2UgWklQIGZpbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRW50cnkgQ2FsbGJhY2sgd2hlbiBlbnRyeSBpcyByZWFkLlxuICogVGhlIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBvbmUgYXJndW1lbnQgb2YgWmlwRW50cnkgdHlwZS5cbiAqIFRoZSBpdGVyYXRpb24gdGhyb3VnaCB0aGUgc291cmNlIHppcCBmaWxlIHdpbGwgYmkgdGVybWluYXRlZCBhcyBzb29uIGFzXG4gKiB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZXF1YWxzIHRvIGBmYWxzZWAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICh6aXBGaWxlUGF0aCwgb25FbnRyeSkge1xuICAvLyBPcGVuIGEgemlwIGZpbGUgYW5kIHN0YXJ0IHJlYWRpbmcgZW50cmllc1xuICBjb25zdCB6aXBmaWxlID0gYXdhaXQgb3BlblppcCh6aXBGaWxlUGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwZmlsZS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAvLyBPbiBlYWNoIGVudHJ5LCBjYWxsICdvbkVudHJ5JyBhbmQgdGhlbiByZWFkIHRoZSBuZXh0IGVudHJ5XG4gICAgemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uRW50cnkoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGFzeW5jIChkZXN0RGlyKSA9PiBhd2FpdCBfZXh0cmFjdEVudHJ5VG8oemlwZmlsZSwgZW50cnksIGRlc3REaXIpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB6aXBmaWxlLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIGVudHJpZXMgdG8gZmluaXNoIGJlaW5nIGl0ZXJhdGVkIHRocm91Z2hcbiAgcmV0dXJuIGF3YWl0IHppcFJlYWRTdHJlYW1Qcm9taXNlO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFppcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5jb2RlVG9CYXNlNjQgW2ZhbHNlXSBXaGV0aGVyIHRvIGVuY29kZVxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWV0ZXJlZCBbdHJ1ZV0gV2hldGhlciB0byBsb2cgdGhlIGFjdHVhbFxuICogYXJjaGl2ZXIgcGVyZm9ybWFuY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTaXplIFsxMDczNzQxODI0XSBUaGUgbWF4aW11bSBzaXplIG9mXG4gKiB0aGUgcmVzdWx0aW5nIGFyY2hpdmUgaW4gYnl0ZXMuIFRoaXMgaXMgc2V0IHRvIDFHQiBieSBkZWZhdWx0LCBiZWNhdXNlXG4gKiBBcHBpdW0gbGltaXRzIHRoZSBtYXhpbXVtIEhUVFAgYm9keSBzaXplIHRvIDFHQi4gQWxzbywgdGhlIE5vZGVKUyBoZWFwXG4gKiBzaXplIG11c3QgYmUgZW5vdWdoIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvYmplY3QgKHVzdWFsbHkgdGhpcyBzaXplIGlzXG4gKiBsaW1pdGVkIHRvIDEuNCBHQilcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gVGhlIGNvbXByZXNzaW9uIGxldmVsLiBUaGUgbWF4aW11bVxuICogbGV2ZWwgaXMgOSAodGhlIGJlc3QgY29tcHJlc3Npb24sIHdvcnN0IHBlcmZvcm1hbmNlKS4gVGhlIG1pbmltdW1cbiAqIGNvbXByZXNzaW9uIGxldmVsIGlzIDAgKG5vIGNvbXByZXNzaW9uKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGNvbnRlbnRzIG9mIGxvY2FsIGRpcmVjdG9yeSB0byBhbiBpbi1tZW1vcnkgLnppcCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmb2xkZXIgb3IgZmlsZSBiZWluZyB6aXBwZWRcbiAqIEBwYXJhbSB7WmlwT3B0aW9uc30gb3B0cyBaaXBwaW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFppcHBlZCAoYW5kIGVuY29kZWQgaWYgYGVuY29kZVRvQmFzZTY0YCBpcyB0cnV0aHkpXG4gKiBjb250ZW50IG9mIHRoZSBzb3VyY2UgcGF0aCBhcyBtZW1vcnkgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJlYWRpbmcgdGhlIHNvdXJjZVxuICogb3IgdGhlIHNvdXJjZSBpcyB0b28gYmlnXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvSW5NZW1vcnlaaXAgKHNyY1BhdGgsIG9wdHMgPSB7fSkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhzcmNQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBmaWxlIG9yIGZvbGRlcjogJHtzcmNQYXRofWApO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gICAgZW5jb2RlVG9CYXNlNjQgPSBmYWxzZSxcbiAgICBtYXhTaXplID0gMSAqIEdpQixcbiAgICBsZXZlbCA9IDksXG4gIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHRCdWZmZXJzID0gW107XG4gIGxldCByZXN1bHRCdWZmZXJzU2l6ZSA9IDA7XG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHppcCBidWZmZXJzIHdpbGwgYmUgc3RyZWFtZWQgdG9cbiAgY29uc3QgcmVzdWx0V3JpdGVTdHJlYW0gPSBuZXcgc3RyZWFtLldyaXRhYmxlKHtcbiAgICB3cml0ZTogKGJ1ZmZlciwgZW5jb2RpbmcsIG5leHQpID0+IHtcbiAgICAgIHJlc3VsdEJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgcmVzdWx0QnVmZmVyc1NpemUgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmIChtYXhTaXplID4gMCAmJiByZXN1bHRCdWZmZXJzU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgcmVzdWx0V3JpdGVTdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgYCArXG4gICAgICAgICAgYGFyY2hpdmUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuICR7dG9SZWFkYWJsZVNpemVTdHJpbmcobWF4U2l6ZSl9YCkpO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8vIFppcCAnc3JjRGlyJyBhbmQgc3RyZWFtIGl0IHRvIHRoZSBhYm92ZSB3cml0YWJsZSBzdHJlYW1cbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7XG4gICAgemxpYjoge2xldmVsfVxuICB9KTtcbiAgbGV0IHNyY1NpemUgPSBudWxsO1xuICBjb25zdCBiYXNlNjRFbmNvZGVyU3RyZWFtID0gZW5jb2RlVG9CYXNlNjQgPyBuZXcgQmFzZTY0RW5jb2RlKCkgOiBudWxsO1xuICBjb25zdCByZXN1bHRXcml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzdWx0V3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCAoZSkgPT4ge1xuICAgICAgaWYgKGJhc2U2NEVuY29kZXJTdHJlYW0pIHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUoYmFzZTY0RW5jb2RlclN0cmVhbSk7XG4gICAgICAgIGJhc2U2NEVuY29kZXJTdHJlYW0udW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgIGFyY2hpdmUuZGVzdHJveSgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJlc3VsdFdyaXRlU3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHNyY1NpemUgPSBhcmNoaXZlLnBvaW50ZXIoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGFyY2hpdmVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFyY2hpdmUub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgYXJjaGl2ZS5vbmNlKCdlcnJvcicsIChlKSA9PiByZWplY3QoXG4gICAgICBuZXcgRXJyb3IoYEZhaWxlZCB0byBhcmNoaXZlICcke3NyY1BhdGh9JzogJHtlLm1lc3NhZ2V9YCkpKTtcbiAgfSk7XG4gIGNvbnN0IHRpbWVyID0gaXNNZXRlcmVkID8gbmV3IFRpbWVyKCkuc3RhcnQoKSA6IG51bGw7XG4gIGlmICgoYXdhaXQgZnMuc3RhdChzcmNQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGFyY2hpdmUuZGlyZWN0b3J5KHNyY1BhdGgsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLmZpbGUoc3JjUGF0aCwge1xuICAgICAgbmFtZTogcGF0aC5iYXNlbmFtZShzcmNQYXRoKSxcbiAgICB9KTtcbiAgfVxuICBpZiAoYmFzZTY0RW5jb2RlclN0cmVhbSkge1xuICAgIGFyY2hpdmUucGlwZShiYXNlNjRFbmNvZGVyU3RyZWFtKTtcbiAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIGFyY2hpdmUucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gIH1cbiAgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBzdHJlYW1zIHRvIGZpbmlzaFxuICBhd2FpdCBCLmFsbChbYXJjaGl2ZVN0cmVhbVByb21pc2UsIHJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZV0pO1xuXG4gIGlmICh0aW1lcikge1xuICAgIGxvZy5kZWJ1ZyhgWmlwcGVkICR7ZW5jb2RlVG9CYXNlNjQgPyAnYW5kIGJhc2U2NC1lbmNvZGVkICcgOiAnJ31gICtcbiAgICAgIGAnJHtwYXRoLmJhc2VuYW1lKHNyY1BhdGgpfScgYCArXG4gICAgICAoc3JjU2l6ZSA/IGAoJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhzcmNTaXplKX0pIGAgOiAnJykgK1xuICAgICAgYGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zIGAgK1xuICAgICAgYChjb21wcmVzc2lvbiBsZXZlbDogJHtsZXZlbH0pYCk7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBhcnJheSBvZiB6aXAgYnVmZmVycyBjb25jYXRlbmF0ZWQgaW50byBvbmUgYnVmZmVyXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KHJlc3VsdEJ1ZmZlcnMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHdoZXRoZXIgdGhlIGdpdmVuIGZpbGUgaXMgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAtIEZ1bGwgcGF0aCB0byB0aGUgZmlsZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhIHZhbGlkIFpJUCBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzc2VydFZhbGlkWmlwIChmaWxlUGF0aCkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhmaWxlUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpO1xuICBpZiAoc2l6ZSA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgaXMgdG9vIHNtYWxsIHRvIGJlIGEgWklQIGFyY2hpdmVgKTtcbiAgfVxuICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4oZmlsZVBhdGgsICdyJyk7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKFpJUF9NQUdJQy5sZW5ndGgpO1xuICAgIGF3YWl0IGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgWklQX01BR0lDLmxlbmd0aCwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmIChzaWduYXR1cmUgIT09IFpJUF9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBzaWduYXR1cmUgJyR7c2lnbmF0dXJlfScgb2YgJyR7ZmlsZVBhdGh9JyBgICtcbiAgICAgICAgYGlzIG5vdCBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgWklQIGFyY2hpdmUgc2lnbmF0dXJlICcke1pJUF9NQUdJQ30nYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLmNsb3NlKGZkKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFppcENvbXByZXNzaW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsIFs5XSAtIENvbXByZXNzaW9uIGxldmVsIGluIHJhbmdlIDAuLjlcbiAqIChncmVhdGVyIG51bWJlcnMgbWVhbiBiZXR0ZXIgY29tcHJlc3Npb24sIGJ1dCBsb25nZXIgcHJvY2Vzc2luZyB0aW1lKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWmlwU291cmNlT3B0aW9uc1xuICogQHByb3BlcnR5IHshc3RyaW5nfSBwYXR0ZXJuIFsnKipcXC8qJ10gLSBHTE9CIHBhdHRlcm4gZm9yIGNvbXByZXNzaW9uXG4gKiBAcHJvcGVydHkgeyFzdHJpbmd9IGN3ZCAtIFRoZSBzb3VyY2Ugcm9vdCBmb2xkZXIgKHRoZSBwYXJlbnQgZm9sZGVyIG9mXG4gKiB0aGUgZGVzdGluYXRpb24gZmlsZSBieSBkZWZhdWx0KVxuICogQHByb3BlcnR5IHs/QXJyYXk8c3RyaW5nPn0gaWdub3JlIC0gVGhlIGxpc3Qgb2YgaWdub3JlZCBwYXR0ZXJuc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcmNoaXZlIGJhc2VkIG9uIHRoZSBnaXZlbiBnbG9iIHBhdHRlcm5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0UGF0aCAtIFRoZSByZXN1bHRpbmcgYXJjaGl2ZSBwYXRoXG4gKiBAcGFyYW0ge1ppcFNvdXJjZU9wdGlvbnN9IHNyYyAtIFNvdXJjZSBvcHRpb25zXG4gKiBAcGFyYW0ge1ppcENvbXByZXNzaW9uT3B0aW9uc30gb3B0cyAtIENvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGFyY2hpdmVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9BcmNoaXZlIChkc3RQYXRoLCBzcmMgPSB7fSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBsZXZlbCA9IDksXG4gIH0gPSBvcHRzO1xuICBjb25zdCB7XG4gICAgcGF0dGVybiA9ICcqKi8qJyxcbiAgICBjd2QgPSBwYXRoLmRpcm5hbWUoZHN0UGF0aCksXG4gICAgaWdub3JlID0gW10sXG4gIH0gPSBzcmM7XG4gIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJywgeyB6bGliOiB7IGxldmVsIH19KTtcbiAgY29uc3Qgc3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZHN0UGF0aCk7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXJjaGl2ZVxuICAgICAgLmdsb2IocGF0dGVybiwge1xuICAgICAgICBjd2QsXG4gICAgICAgIGlnbm9yZSxcbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgLnBpcGUoc3RyZWFtKTtcbiAgICBzdHJlYW1cbiAgICAgIC5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBhcmNoaXZlLnVucGlwZShzdHJlYW0pO1xuICAgICAgICBhcmNoaXZlLmFib3J0KCk7XG4gICAgICAgIGFyY2hpdmUuZGVzdHJveSgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdmaW5pc2gnLCByZXNvbHZlKTtcbiAgICBhcmNoaXZlLmZpbmFsaXplKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZpbmRzIGFuZCBtZW1vaXplcyB0aGUgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBleGVjdXRhYmxlLlxuICogUmVqZWN0cyBpZiBpdCBpcyBub3QgZm91bmQuXG4gKi9cbmNvbnN0IGdldEV4ZWN1dGFibGVQYXRoID0gXy5tZW1vaXplKFxuICAvKipcbiAgICogQHJldHVybnMge0I8c3RyaW5nPn0gRnVsbCBQYXRoIHRvIHRoZSBleGVjdXRhYmxlXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBnZXRFeGVjdXRhYmxlUGF0aCAoYmluYXJ5TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYXdhaXQgZnMud2hpY2goYmluYXJ5TmFtZSk7XG4gICAgbG9nLmRlYnVnKGBGb3VuZCAnJXMnIGF0ICclcydgLCBiaW5hcnlOYW1lLCBmdWxsUGF0aCk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xuICB9XG4pO1xuXG5leHBvcnQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBfZXh0cmFjdEVudHJ5VG8sXG4gIGFzc2VydFZhbGlkWmlwLCB0b0FyY2hpdmUgfTtcbmV4cG9ydCBkZWZhdWx0IHsgZXh0cmFjdEFsbFRvLCByZWFkRW50cmllcywgdG9Jbk1lbW9yeVppcCwgYXNzZXJ0VmFsaWRaaXAsIHRvQXJjaGl2ZSB9O1xuIl0sImZpbGUiOiJsaWIvemlwLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
