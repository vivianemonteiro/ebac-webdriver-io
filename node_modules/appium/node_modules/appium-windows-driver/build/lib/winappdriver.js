"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WinAppDriver = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _appiumBaseDriver = require("appium-base-driver");

var _logger = _interopRequireDefault(require("./logger"));

var _teen_process = require("teen_process");

var _installer = require("./installer");

var _asyncbox = require("asyncbox");

var _child_process = require("child_process");

var _appiumSupport = require("appium-support");

var _portscanner = require("portscanner");

const DEFAULT_BASE = '/wd/hub';
const DEFAULT_HOST = '127.0.0.1';
const WAD_PORT_RANGE = [4724, 4824];
const STARTUP_TIMEOUT_MS = 10000;
const DEFAULT_CREATE_SESSION_TIMEOUT_MS = 20000;

const PORT_ALLOCATION_GUARD = _appiumSupport.util.getLockFileGuard(_path.default.resolve(_os.default.tmpdir(), 'wad_port_guard'), {
  timeout: 5,
  tryRecovery: true
});

class WADProxy extends _appiumBaseDriver.JWProxy {
  async proxyCommand(url, method, body = null) {
    if (this.didProcessExit) {
      throw new _appiumBaseDriver.errors.InvalidContextError(`'${method} ${url}' cannot be proxied to WinAppDriver server because ` + 'its process is not running (probably crashed). Check the Appium log for more details');
    }

    return await super.proxyCommand(url, method, body);
  }

}

class WADProcess {
  constructor(opts = {}) {
    this.base = opts.base;
    this.port = opts.port;
    this.executablePath = opts.executablePath;
    this.proc = null;
  }

  get isRunning() {
    var _this$proc;

    return !!((_this$proc = this.proc) !== null && _this$proc !== void 0 && _this$proc.isRunning);
  }

  async start() {
    if (this.isRunning) {
      return;
    }

    if (!this.port) {
      await PORT_ALLOCATION_GUARD(async () => {
        const [startPort, endPort] = WAD_PORT_RANGE;

        try {
          this.port = await (0, _portscanner.findAPortNotInUse)(startPort, endPort);
        } catch (e) {
          _logger.default.errorAndThrow(`Could not find any free port in range ${startPort}..${endPort}. ` + `Please check your system firewall settings or set 'systemPort' capability ` + `to the desired port number`);
        }
      });
    }

    const args = [`${this.port}${this.base}`];
    this.proc = new _teen_process.SubProcess(this.executablePath, args, {
      encoding: 'ucs2'
    });
    this.proc.on('output', (stdout, stderr) => {
      const line = _lodash.default.trim(stderr || stdout);

      if (line) {
        _logger.default.debug(line);
      }
    });
    this.proc.on('exit', (code, signal) => {
      _logger.default.info(`WinAppDriver exited with code ${code}, signal ${signal}`);
    });

    _logger.default.info(`Spawning '${this.executablePath}' with args: ${JSON.stringify(args)}`);

    await this.proc.start(0);
  }

  async stop() {
    if (this.isRunning) {
      try {
        await this.proc.stop();
      } catch (e) {
        _logger.default.warn(`WinAppDriver process with PID ${this.proc.pid} cannot be stopped. ` + `Original error: ${e.message}`);
      }
    }
  }

}

const RUNNING_PROCESS_IDS = [];
process.once('exit', () => {
  for (const pid of RUNNING_PROCESS_IDS) {
    const command = `taskkill.exe /PID ${pid}`;

    try {
      (0, _child_process.execSync)(command);
    } catch (e) {
      _logger.default.warn(`WinAppDriver process with PID ${pid} cannot be cleaned up. ` + `Original error: ${e.message}`);
    }
  }
});

class WinAppDriver {
  constructor(opts = {}) {
    this.proxyPort = opts.port;
    this.process = null;
    this.proxy = null;
  }

  async start(caps) {
    const executablePath = await (0, _installer.getWADExecutablePath)();

    if (!(await (0, _installer.isWADChecksumOk)(executablePath))) {
      _logger.default.warn('WinAppDriver exists, but the checksum did not match. Was it replaced manually?');
    }

    this.process = new WADProcess({
      base: DEFAULT_BASE,
      port: this.proxyPort,
      executablePath
    });
    await this.process.start();
    this.proxy = new WADProxy({
      server: DEFAULT_HOST,
      port: this.process.port
    });
    this.proxy.didProcessExit = false;
    this.process.proc.on('exit', () => {
      this.proxy.didProcessExit = true;
    });

    try {
      await (0, _asyncbox.waitForCondition)(async () => {
        try {
          await this.proxy.command('/status', 'GET');
          return true;
        } catch (err) {
          if (this.proxy.didProcessExit) {
            throw new Error(err.message);
          }

          return false;
        }
      }, {
        waitMs: STARTUP_TIMEOUT_MS,
        intervalMs: 1000
      });
    } catch (e) {
      if (/Condition unmet/.test(e.message)) {
        throw new Error(`WinAppDriver server is not listening within ${STARTUP_TIMEOUT_MS}ms timeout. ` + `Make sure it could be started manually`);
      }

      throw e;
    }

    const pid = this.process.proc.pid;
    RUNNING_PROCESS_IDS.push(pid);
    this.process.proc.on('exit', () => void _lodash.default.pull(RUNNING_PROCESS_IDS, pid));
    await this._startSession(caps);
  }

  async _startSession(desiredCapabilities) {
    const {
      createSessionTimeout = DEFAULT_CREATE_SESSION_TIMEOUT_MS
    } = desiredCapabilities;

    _logger.default.debug(`Starting WinAppDriver session. Will timeout in '${createSessionTimeout}' ms.`);

    let retryIteration = 0;
    let lastError;

    const condFn = async () => {
      lastError = null;
      retryIteration++;

      try {
        await this.proxy.command('/session', 'POST', {
          desiredCapabilities
        });
        return true;
      } catch (error) {
        lastError = error;

        _logger.default.warn(`Could not start WinAppDriver session error = '${error.message}', attempt = '${retryIteration}' from '${this.createSessionRetry}'`);

        return false;
      }
    };

    try {
      await (0, _asyncbox.waitForCondition)(condFn, {
        waitMs: createSessionTimeout,
        intervalMs: 500
      });
    } catch (timeoutError) {
      _logger.default.debug(`timeoutError was ${timeoutError.message}`);

      if (lastError) {
        throw lastError;
      }

      throw new Error(`Could not start WinAppDriver session within ${createSessionTimeout} ms.`);
    }
  }

  async stop() {
    var _this$process, _this$proxy;

    if (!((_this$process = this.process) !== null && _this$process !== void 0 && _this$process.isRunning)) {
      return;
    }

    if ((_this$proxy = this.proxy) !== null && _this$proxy !== void 0 && _this$proxy.sessionId) {
      _logger.default.debug('Deleting WinAppDriver server session');

      try {
        var _this$proxy2;

        await this.proxy.command(`/session/${(_this$proxy2 = this.proxy) === null || _this$proxy2 === void 0 ? void 0 : _this$proxy2.sessionId}`, 'DELETE');
      } catch (err) {
        _logger.default.warn(`Did not get confirmation WinAppDriver deleteSession worked; ` + `Error was: ${err.message}`);
      }
    }

    await this.process.stop();
  }

  async sendCommand(url, method, body) {
    return await this.proxy.command(url, method, body);
  }

}

exports.WinAppDriver = WinAppDriver;
var _default = WinAppDriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93aW5hcHBkcml2ZXIuanMiXSwibmFtZXMiOlsiREVGQVVMVF9CQVNFIiwiREVGQVVMVF9IT1NUIiwiV0FEX1BPUlRfUkFOR0UiLCJTVEFSVFVQX1RJTUVPVVRfTVMiLCJERUZBVUxUX0NSRUFURV9TRVNTSU9OX1RJTUVPVVRfTVMiLCJQT1JUX0FMTE9DQVRJT05fR1VBUkQiLCJ1dGlsIiwiZ2V0TG9ja0ZpbGVHdWFyZCIsInBhdGgiLCJyZXNvbHZlIiwib3MiLCJ0bXBkaXIiLCJ0aW1lb3V0IiwidHJ5UmVjb3ZlcnkiLCJXQURQcm94eSIsIkpXUHJveHkiLCJwcm94eUNvbW1hbmQiLCJ1cmwiLCJtZXRob2QiLCJib2R5IiwiZGlkUHJvY2Vzc0V4aXQiLCJlcnJvcnMiLCJJbnZhbGlkQ29udGV4dEVycm9yIiwiV0FEUHJvY2VzcyIsImNvbnN0cnVjdG9yIiwib3B0cyIsImJhc2UiLCJwb3J0IiwiZXhlY3V0YWJsZVBhdGgiLCJwcm9jIiwiaXNSdW5uaW5nIiwic3RhcnQiLCJzdGFydFBvcnQiLCJlbmRQb3J0IiwiZSIsImxvZyIsImVycm9yQW5kVGhyb3ciLCJhcmdzIiwiU3ViUHJvY2VzcyIsImVuY29kaW5nIiwib24iLCJzdGRvdXQiLCJzdGRlcnIiLCJsaW5lIiwiXyIsInRyaW0iLCJkZWJ1ZyIsImNvZGUiLCJzaWduYWwiLCJpbmZvIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0b3AiLCJ3YXJuIiwicGlkIiwibWVzc2FnZSIsIlJVTk5JTkdfUFJPQ0VTU19JRFMiLCJwcm9jZXNzIiwib25jZSIsImNvbW1hbmQiLCJXaW5BcHBEcml2ZXIiLCJwcm94eVBvcnQiLCJwcm94eSIsImNhcHMiLCJzZXJ2ZXIiLCJlcnIiLCJFcnJvciIsIndhaXRNcyIsImludGVydmFsTXMiLCJ0ZXN0IiwicHVzaCIsInB1bGwiLCJfc3RhcnRTZXNzaW9uIiwiZGVzaXJlZENhcGFiaWxpdGllcyIsImNyZWF0ZVNlc3Npb25UaW1lb3V0IiwicmV0cnlJdGVyYXRpb24iLCJsYXN0RXJyb3IiLCJjb25kRm4iLCJlcnJvciIsImNyZWF0ZVNlc3Npb25SZXRyeSIsInRpbWVvdXRFcnJvciIsInNlc3Npb25JZCIsInNlbmRDb21tYW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLFlBQVksR0FBRyxTQUFyQjtBQUNBLE1BQU1DLFlBQVksR0FBRyxXQUFyQjtBQUNBLE1BQU1DLGNBQWMsR0FBRyxDQUFDLElBQUQsRUFBTyxJQUFQLENBQXZCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsS0FBM0I7QUFDQSxNQUFNQyxpQ0FBaUMsR0FBRyxLQUExQzs7QUFHQSxNQUFNQyxxQkFBcUIsR0FBR0Msb0JBQUtDLGdCQUFMLENBQXNCQyxjQUFLQyxPQUFMLENBQWFDLFlBQUdDLE1BQUgsRUFBYixFQUEwQixnQkFBMUIsQ0FBdEIsRUFBbUU7QUFDL0ZDLEVBQUFBLE9BQU8sRUFBRSxDQURzRjtBQUUvRkMsRUFBQUEsV0FBVyxFQUFFO0FBRmtGLENBQW5FLENBQTlCOztBQUtBLE1BQU1DLFFBQU4sU0FBdUJDLHlCQUF2QixDQUErQjtBQUNYLFFBQVpDLFlBQVksQ0FBRUMsR0FBRixFQUFPQyxNQUFQLEVBQWVDLElBQUksR0FBRyxJQUF0QixFQUE0QjtBQUM1QyxRQUFJLEtBQUtDLGNBQVQsRUFBeUI7QUFDdkIsWUFBTSxJQUFJQyx5QkFBT0MsbUJBQVgsQ0FDSCxJQUFHSixNQUFPLElBQUdELEdBQUkscURBQWxCLEdBQ0Esc0ZBRkksQ0FBTjtBQUdEOztBQUNELFdBQU8sTUFBTSxNQUFNRCxZQUFOLENBQW1CQyxHQUFuQixFQUF3QkMsTUFBeEIsRUFBZ0NDLElBQWhDLENBQWI7QUFDRDs7QUFSNEI7O0FBVy9CLE1BQU1JLFVBQU4sQ0FBaUI7QUFDZkMsRUFBQUEsV0FBVyxDQUFFQyxJQUFJLEdBQUcsRUFBVCxFQUFhO0FBQ3RCLFNBQUtDLElBQUwsR0FBWUQs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QixZQUFELGdCQUFZLEtBQUtHLEtBQWpCLGlEQUFZLGFBQVltQixTQUFVLEVBQXJELEVBQXdELFFBQXhELENBQU47QUFDRCxPQUZELENBRUUsT0FBT2hCLEdBQVAsRUFBWTtBQUNaOUIsd0JBQUlrQixJQUFKLENBQVUsOERBQUQsR0FDTixjQUFhWSxHQUFHLENBQUNWLE9BQVEsRUFENUI7QUFFRDtBQUNGOztBQUVELFVBQU0sS0FBS0UsT0FBTCxDQUFhTCxJQUFiLEVBQU47QUFDRDs7QUFFZ0IsUUFBWDhCLFdBQVcsQ0FBRWpFLEdBQUYsRUFBT0MsTUFBUCxFQUFlQyxJQUFmLEVBQXFCO0FBQ3BDLFdBQU8sTUFBTSxLQUFLMkMsS0FBTCxDQUFXSCxPQUFYLENBQW1CMUMsR0FBbkIsRUFBd0JDLE1BQXhCLEVBQWdDQyxJQUFoQyxDQUFiO0FBQ0Q7O0FBbkhnQjs7O2VBdUhKeUMsWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBKV1Byb3h5LCBlcnJvcnMgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IGdldFdBREV4ZWN1dGFibGVQYXRoLCBpc1dBRENoZWNrc3VtT2sgfSBmcm9tICcuL2luc3RhbGxlcic7XG5pbXBvcnQgeyB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBmaW5kQVBvcnROb3RJblVzZSB9IGZyb20gJ3BvcnRzY2FubmVyJztcblxuXG5jb25zdCBERUZBVUxUX0JBU0UgPSAnL3dkL2h1Yic7XG5jb25zdCBERUZBVUxUX0hPU1QgPSAnMTI3LjAuMC4xJztcbmNvbnN0IFdBRF9QT1JUX1JBTkdFID0gWzQ3MjQsIDQ4MjRdO1xuY29uc3QgU1RBUlRVUF9USU1FT1VUX01TID0gMTAwMDA7XG5jb25zdCBERUZBVUxUX0NSRUFURV9TRVNTSU9OX1RJTUVPVVRfTVMgPSAyMDAwMDsgLy8gcmV0cnkgc3RhcnQgc2Vzc2lvbiBjcmVhdGlvbiBkdXJpbmcgdGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4vLyBUaGUgZ3VhcmQgaXMgbmVlZGVkIHRvIGF2b2lkIGR5bmFtaWMgc3lzdGVtIHBvcnQgYWxsb2NhdGlvbiBjb25mbGljdHMgZm9yXG4vLyBwYXJhbGxlbCBkcml2ZXIgc2Vzc2lvbnNcbmNvbnN0IFBPUlRfQUxMT0NBVElPTl9HVUFSRCA9IHV0aWwuZ2V0TG9ja0ZpbGVHdWFyZChwYXRoLnJlc29sdmUob3MudG1wZGlyKCksICd3YWRfcG9ydF9ndWFyZCcpLCB7XG4gIHRpbWVvdXQ6IDUsXG4gIHRyeVJlY292ZXJ5OiB0cnVlLFxufSk7XG5cbmNsYXNzIFdBRFByb3h5IGV4dGVuZHMgSldQcm94eSB7XG4gIGFzeW5jIHByb3h5Q29tbWFuZCAodXJsLCBtZXRob2QsIGJvZHkgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuZGlkUHJvY2Vzc0V4aXQpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZENvbnRleHRFcnJvcihcbiAgICAgICAgYCcke21ldGhvZH0gJHt1cmx9JyBjYW5ub3QgYmUgcHJveGllZCB0byBXaW5BcHBEcml2ZXIgc2VydmVyIGJlY2F1c2UgYCArXG4gICAgICAgICdpdHMgcHJvY2VzcyBpcyBub3QgcnVubmluZyAocHJvYmFibHkgY3Jhc2hlZCkuIENoZWNrIHRoZSBBcHBpdW0gbG9nIGZvciBtb3JlIGRldGFpbHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLnByb3h5Q29tbWFuZCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gIH1cbn1cblxuY2xhc3MgV0FEUHJvY2VzcyB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICB0aGlzLmJhc2UgPSBvcHRzLmJhc2U7XG4gICAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICAgIHRoaXMuZXhlY3V0YWJsZVBhdGggPSBvcHRzLmV4ZWN1dGFibGVQYXRoO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gIH1cblxuICBnZXQgaXNSdW5uaW5nICgpIHtcbiAgICByZXR1cm4gISEodGhpcy5wcm9jPy5pc1J1bm5pbmcpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKCkge1xuICAgIGlmICh0aGlzLmlzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wb3J0KSB7XG4gICAgICBhd2FpdCBQT1JUX0FMTE9DQVRJT05fR1VBUkQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBbc3RhcnRQb3J0LCBlbmRQb3J0XSA9IFdBRF9QT1JUX1JBTkdFO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucG9ydCA9IGF3YWl0IGZpbmRBUG9ydE5vdEluVXNlKHN0YXJ0UG9ydCwgZW5kUG9ydCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhcbiAgICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBhbnkgZnJlZSBwb3J0IGluIHJhbmdlICR7c3RhcnRQb3J0fS4uJHtlbmRQb3J0fS4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIGNoZWNrIHlvdXIgc3lzdGVtIGZpcmV3YWxsIHNldHRpbmdzIG9yIHNldCAnc3lzdGVtUG9ydCcgY2FwYWJpbGl0eSBgICtcbiAgICAgICAgICAgIGB0byB0aGUgZGVzaXJlZCBwb3J0IG51bWJlcmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gW2Ake3RoaXMucG9ydH0ke3RoaXMuYmFzZX1gXTtcbiAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmV4ZWN1dGFibGVQYXRoLCBhcmdzLCB7XG4gICAgICBlbmNvZGluZzogJ3VjczInXG4gICAgfSk7XG4gICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSBfLnRyaW0oc3RkZXJyIHx8IHN0ZG91dCk7XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICBsb2cuZGVidWcobGluZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgbG9nLmluZm8oYFdpbkFwcERyaXZlciBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX0sIHNpZ25hbCAke3NpZ25hbH1gKTtcbiAgICB9KTtcbiAgICBsb2cuaW5mbyhgU3Bhd25pbmcgJyR7dGhpcy5leGVjdXRhYmxlUGF0aH0nIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgICBhd2FpdCB0aGlzLnByb2Muc3RhcnQoMCk7XG4gIH1cblxuICBhc3luYyBzdG9wICgpIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy53YXJuKGBXaW5BcHBEcml2ZXIgcHJvY2VzcyB3aXRoIFBJRCAke3RoaXMucHJvYy5waWR9IGNhbm5vdCBiZSBzdG9wcGVkLiBgICtcbiAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBSVU5OSU5HX1BST0NFU1NfSURTID0gW107XG5wcm9jZXNzLm9uY2UoJ2V4aXQnLCAoKSA9PiB7XG4gIGZvciAoY29uc3QgcGlkIG9mIFJVTk5JTkdfUFJPQ0VTU19JRFMpIHtcbiAgICBjb25zdCBjb21tYW5kID0gYHRhc2traWxsLmV4ZSAvUElEICR7cGlkfWA7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGNvbW1hbmQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy53YXJuKGBXaW5BcHBEcml2ZXIgcHJvY2VzcyB3aXRoIFBJRCAke3BpZH0gY2Fubm90IGJlIGNsZWFuZWQgdXAuIGAgK1xuICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxufSk7XG5cbmNsYXNzIFdpbkFwcERyaXZlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICB0aGlzLnByb3h5UG9ydCA9IG9wdHMucG9ydDtcblxuICAgIHRoaXMucHJvY2VzcyA9IG51bGw7XG4gICAgdGhpcy5wcm94eSA9IG51bGw7XG4gIH1cblxuICBhc3luYyBzdGFydCAoY2Fwcykge1xuICAgIGNvbnN0IGV4ZWN1dGFibGVQYXRoID0gYXdhaXQgZ2V0V0FERXhlY3V0YWJsZVBhdGgoKTtcbiAgICBpZiAoIWF3YWl0IGlzV0FEQ2hlY2tzdW1PayhleGVjdXRhYmxlUGF0aCkpIHtcbiAgICAgIGxvZy53YXJuKCdXaW5BcHBEcml2ZXIgZXhpc3RzLCBidXQgdGhlIGNoZWNrc3VtIGRpZCBub3QgbWF0Y2guIFdhcyBpdCByZXBsYWNlZCBtYW51YWxseT8nKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2Nlc3MgPSBuZXcgV0FEUHJvY2Vzcyh7XG4gICAgICAvLyBYWFhZRCBUT0RPOiB3b3VsZCBiZSBiZXR0ZXIgaWYgV2luQXBwRHJpdmVyIGRpZG4ndCByZXF1aXJlIHBhc3NpbmcgaW4gL3dkL2h1YiBhcyBhIHBhcmFtXG4gICAgICBiYXNlOiBERUZBVUxUX0JBU0UsXG4gICAgICBwb3J0OiB0aGlzLnByb3h5UG9ydCxcbiAgICAgIGV4ZWN1dGFibGVQYXRoLFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMucHJvY2Vzcy5zdGFydCgpO1xuXG4gICAgdGhpcy5wcm94eSA9IG5ldyBXQURQcm94eSh7XG4gICAgICBzZXJ2ZXI6IERFRkFVTFRfSE9TVCxcbiAgICAgIHBvcnQ6IHRoaXMucHJvY2Vzcy5wb3J0LFxuICAgIH0pO1xuICAgIHRoaXMucHJveHkuZGlkUHJvY2Vzc0V4aXQgPSBmYWxzZTtcbiAgICB0aGlzLnByb2Nlc3MucHJvYy5vbignZXhpdCcsICgpID0+IHtcbiAgICAgIHRoaXMucHJveHkuZGlkUHJvY2Vzc0V4aXQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucHJveHkuY29tbWFuZCgnL3N0YXR1cycsICdHRVQnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJveHkuZGlkUHJvY2Vzc0V4aXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB3YWl0TXM6IFNUQVJUVVBfVElNRU9VVF9NUyxcbiAgICAgICAgaW50ZXJ2YWxNczogMTAwMCxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICgvQ29uZGl0aW9uIHVubWV0Ly50ZXN0KGUubWVzc2FnZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaW5BcHBEcml2ZXIgc2VydmVyIGlzIG5vdCBsaXN0ZW5pbmcgd2l0aGluICR7U1RBUlRVUF9USU1FT1VUX01TfW1zIHRpbWVvdXQuIGAgK1xuICAgICAgICAgIGBNYWtlIHN1cmUgaXQgY291bGQgYmUgc3RhcnRlZCBtYW51YWxseWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgY29uc3QgcGlkID0gdGhpcy5wcm9jZXNzLnByb2MucGlkO1xuICAgIFJVTk5JTkdfUFJPQ0VTU19JRFMucHVzaChwaWQpO1xuICAgIHRoaXMucHJvY2Vzcy5wcm9jLm9uKCdleGl0JywgKCkgPT4gdm9pZCBfLnB1bGwoUlVOTklOR19QUk9DRVNTX0lEUywgcGlkKSk7XG5cbiAgICBhd2FpdCB0aGlzLl9zdGFydFNlc3Npb24oY2Fwcyk7XG4gIH1cblxuICBhc3luYyBfc3RhcnRTZXNzaW9uIChkZXNpcmVkQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2Vzc2lvblRpbWVvdXQgPSBERUZBVUxUX0NSRUFURV9TRVNTSU9OX1RJTUVPVVRfTVNcbiAgICB9ID0gZGVzaXJlZENhcGFiaWxpdGllcztcbiAgICBsb2cuZGVidWcoYFN0YXJ0aW5nIFdpbkFwcERyaXZlciBzZXNzaW9uLiBXaWxsIHRpbWVvdXQgaW4gJyR7Y3JlYXRlU2Vzc2lvblRpbWVvdXR9JyBtcy5gKTtcbiAgICBsZXQgcmV0cnlJdGVyYXRpb24gPSAwO1xuICAgIGxldCBsYXN0RXJyb3I7XG5cbiAgICBjb25zdCBjb25kRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgcmV0cnlJdGVyYXRpb24rKztcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgIGxvZy53YXJuKGBDb3VsZCBub3Qgc3RhcnQgV2luQXBwRHJpdmVyIHNlc3Npb24gZXJyb3IgPSAnJHtlcnJvci5tZXNzYWdlfScsIGF0dGVtcHQgPSAnJHtyZXRyeUl0ZXJhdGlvbn0nIGZyb20gJyR7dGhpcy5jcmVhdGVTZXNzaW9uUmV0cnl9J2ApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGNvbmRGbiwge1xuICAgICAgICB3YWl0TXM6IGNyZWF0ZVNlc3Npb25UaW1lb3V0LFxuICAgICAgICBpbnRlcnZhbE1zOiA1MDBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHRpbWVvdXRFcnJvcikge1xuICAgICAgbG9nLmRlYnVnKGB0aW1lb3V0RXJyb3Igd2FzICR7dGltZW91dEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgIHRocm93IChsYXN0RXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgc3RhcnQgV2luQXBwRHJpdmVyIHNlc3Npb24gd2l0aGluICR7Y3JlYXRlU2Vzc2lvblRpbWVvdXR9IG1zLmApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0b3AgKCkge1xuICAgIGlmICghdGhpcy5wcm9jZXNzPy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm94eT8uc2Vzc2lvbklkKSB7XG4gICAgICBsb2cuZGVidWcoJ0RlbGV0aW5nIFdpbkFwcERyaXZlciBzZXJ2ZXIgc2Vzc2lvbicpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm94eS5jb21tYW5kKGAvc2Vzc2lvbi8ke3RoaXMucHJveHk/LnNlc3Npb25JZH1gLCAnREVMRVRFJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLndhcm4oYERpZCBub3QgZ2V0IGNvbmZpcm1hdGlvbiBXaW5BcHBEcml2ZXIgZGVsZXRlU2Vzc2lvbiB3b3JrZWQ7IGAgK1xuICAgICAgICAgIGBFcnJvciB3YXM6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wcm9jZXNzLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3h5LmNvbW1hbmQodXJsLCBtZXRob2QsIGJvZHkpO1xuICB9XG59XG5cbmV4cG9ydCB7IFdpbkFwcERyaXZlciB9O1xuZXhwb3J0IGRlZmF1bHQgV2luQXBwRHJpdmVyO1xuIl0sImZpbGUiOiJsaWIvd2luYXBwZHJpdmVyLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
